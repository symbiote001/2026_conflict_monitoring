<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="color-scheme" content="dark light" />
  <title>Research-Grade Conflict Monitoring Platform ‚Äî Epistemology √ó Peace Informatics</title>
  <style>
    /* =========================================================
       RESEARCH PLATFORM: PhD-Grade Visual System
       Theory: Information hierarchies must be visually distinguishable.
       Method: Token-based theming + clear semantic layers.
       Expected outcome: Cognitive load reduction for complex analysis.
    ========================================================== */
    :root{
      --bg0:#070A12; --bg1:#0C1222; --card:#0F1A2E; --card2:#0B1426;
      --txt:#EAF1FF; --muted:#A9B7D6; --faint:#7C89A6;
      --accent:#7CF7C5; --accent2:#86B7FF; --warn:#FFD27D; --bad:#FF7D9B; --good:#7DFFB2;
      --purple:#D4A5FF; --orange:#FFAB70;
      --line:rgba(255,255,255,.12); --shadow: 0 16px 50px rgba(0,0,0,.45);
      --radius: 18px; --radius2: 26px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }
    *{box-sizing:border-box; margin:0; padding:0}
    html,body{height:100%}
    body{
      font-family:var(--sans); color:var(--txt);
      background: radial-gradient(1200px 700px at 20% 10%, rgba(134,183,255,.18), transparent 55%),
                  radial-gradient(900px 600px at 80% 20%, rgba(124,247,197,.12), transparent 50%),
                  linear-gradient(180deg,var(--bg0),var(--bg1));
      overflow-x:hidden;
    }
    a{color:var(--accent2); text-decoration:none}
    a:hover{text-decoration:underline}
    code,pre{font-family:var(--mono); font-size:13px}
    pre{
      background:rgba(0,0,0,.3); border:1px solid var(--line); border-radius:12px;
      padding:10px 12px; overflow-x:auto; line-height:1.4;
    }
    .wrap{max-width:1400px; margin:0 auto; padding:18px 16px 70px}
    .row{display:flex; gap:14px; flex-wrap:wrap}
    .col{flex:1 1 320px}
    .col2{flex:1 1 480px}
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border:1px solid var(--line); border-radius:var(--radius);
      box-shadow:var(--shadow); backdrop-filter: blur(8px); overflow:hidden;
    }
    .card .hd{
      padding:14px 14px 10px; border-bottom:1px solid var(--line);
      display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap;
    }
    .card .bd{padding:14px; line-height:1.5}
    .pill{
      border:1px solid var(--line); border-radius:999px; padding:6px 10px; font-size:12px;
      color:var(--muted); background: rgba(0,0,0,.18);
      display:inline-flex; align-items:center; gap:8px; white-space:nowrap;
    }
    .pill b{color:var(--txt); font-weight:650}
    .btn{
      appearance:none; border:1px solid var(--line); background: rgba(0,0,0,.20);
      color:var(--txt); padding:10px 12px; border-radius:14px; cursor:pointer;
      transition: transform .06s ease, border-color .2s, background .2s; font-weight:650; font-size:13px;
    }
    .btn:hover{border-color:rgba(255,255,255,.24); background: rgba(0,0,0,.28)}
    .btn:active{transform: translateY(1px)}
    .btn.primary{border-color: rgba(124,247,197,.35); background: rgba(124,247,197,.14)}
    .btn.primary:hover{border-color: rgba(124,247,197,.55); background: rgba(124,247,197,.18)}
    .btn.danger{border-color: rgba(255,125,155,.38); background: rgba(255,125,155,.14)}
    .btn.small{padding:7px 10px; border-radius:12px; font-size:12px}
    .muted{color:var(--muted)}
    .faint{color:var(--faint)}
    h1,h2,h3,h4{margin:0; line-height:1.2}
    h1{font-size:24px; letter-spacing:.2px}
    h2{font-size:18px; font-weight:800}
    h3{font-size:15px; font-weight:750}
    h4{font-size:14px; font-weight:700}
    .k{font-family:var(--mono); font-size:12px; color:var(--muted)}
    .sep{height:1px; background:var(--line); margin:12px 0}
    .grid2{display:grid; grid-template-columns: 1fr 1fr; gap:12px}
    .grid3{display:grid; grid-template-columns: 1fr 1fr 1fr; gap:12px}
    .grid4{display:grid; grid-template-columns: repeat(4, 1fr); gap:12px}
    @media (max-width: 1100px){.grid3,.grid4{grid-template-columns:1fr 1fr}}
    @media (max-width: 700px){.grid2,.grid3,.grid4{grid-template-columns:1fr}}
    input,select,textarea{
      width:100%; border-radius:14px; border:1px solid var(--line);
      background: rgba(0,0,0,.22); color:var(--txt); padding:10px 12px; outline:none; font-size:13px;
    }
    textarea{min-height:96px; resize:vertical; font-family:var(--mono)}
    label{display:block; font-size:12px; color:var(--muted); margin:8px 0 6px; font-weight:600}
    .tiny{font-size:12px; line-height:1.45}
    .tag{
      display:inline-flex; align-items:center; gap:6px; padding:4px 8px; border-radius:999px;
      border:1px solid var(--line); background: rgba(0,0,0,.22);
      font-size:11px; color:var(--muted); margin:3px 6px 3px 0; font-weight:600;
    }
    .tag.good{border-color: rgba(125,255,178,.35); color: var(--good); background:rgba(125,255,178,.08)}
    .tag.warn{border-color: rgba(255,210,125,.35); color: var(--warn); background:rgba(255,210,125,.08)}
    .tag.bad{border-color: rgba(255,125,155,.35); color: var(--bad); background:rgba(255,125,155,.08)}
    .tag.purple{border-color: rgba(212,165,255,.35); color: var(--purple); background:rgba(212,165,255,.08)}
    .tag.orange{border-color: rgba(255,171,112,.35); color: var(--orange); background:rgba(255,171,112,.08)}
    .mono{font-family:var(--mono)}
    .right{display:flex; gap:10px; align-items:center; justify-content:flex-end; flex-wrap:wrap}

    /* Sticky nav */
    .topbar{
      position:sticky; top:0; z-index:30;
      background: linear-gradient(180deg, rgba(7,10,18,.92), rgba(7,10,18,.58));
      border-bottom:1px solid var(--line); backdrop-filter: blur(10px);
    }
    .topbar .inner{
      max-width:1400px; margin:0 auto; padding:10px 16px;
      display:flex; align-items:center; gap:12px; justify-content:space-between; flex-wrap:wrap;
    }
    .brand{display:flex; align-items:center; gap:10px; min-width: 280px}
    .logo{
      width:36px; height:36px; border-radius:12px;
      background: radial-gradient(circle at 30% 30%, rgba(124,247,197,.9), rgba(134,183,255,.35) 40%, transparent 70%),
                  linear-gradient(135deg, rgba(255,255,255,.12), rgba(255,255,255,.02));
      border:1px solid rgba(255,255,255,.16); box-shadow: 0 12px 26px rgba(0,0,0,.45);
      position:relative; overflow:hidden;
    }
    .logo::after{
      content:""; position:absolute; inset:-20px;
      background: radial-gradient(circle at 50% 50%, rgba(255,255,255,.18), transparent 55%);
      transform: rotate(20deg);
    }
    .nav{display:flex; gap:6px; flex-wrap:wrap; justify-content:center}
    .nav a{
      font-size:11px; color:var(--muted); padding:7px 9px;
      border:1px solid transparent; border-radius:999px; font-weight:600;
    }
    .nav a:hover{color:var(--txt); border-color: var(--line); background: rgba(0,0,0,.2); text-decoration:none}
    .searchBox{min-width:240px; max-width:340px; width:30vw}
    .searchBox input{padding:9px 12px; border-radius:999px}

    /* Hero parallax */
    .hero{
      position:relative; border-radius: var(--radius2); overflow:hidden;
      border:1px solid var(--line); box-shadow: var(--shadow); margin-top:16px;
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
    }
    .hero .bg{
      position:absolute; inset:-60px;
      background: radial-gradient(800px 380px at 20% 20%, rgba(134,183,255,.22), transparent 60%),
                  radial-gradient(700px 360px at 80% 40%, rgba(124,247,197,.16), transparent 60%),
                  radial-gradient(420px 280px at 55% 85%, rgba(255,210,125,.12), transparent 60%);
      transform: translate3d(var(--px,0), var(--py,0), 0) scale(1.02); filter: saturate(1.05);
    }
    .hero .fg{position:relative; padding:18px 16px 14px}
    .hero .title{display:flex; gap:14px; align-items:flex-start; justify-content:space-between; flex-wrap:wrap}
    .hero p{margin:8px 0 0; color:var(--muted); max-width: 90ch; line-height:1.5}
    .hero .badges{display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content:flex-end}

    /* Splash */
    .splash{
      position:fixed; inset:0; z-index:100;
      background: radial-gradient(1100px 700px at 20% 10%, rgba(134,183,255,.25), transparent 55%),
                  radial-gradient(900px 600px at 80% 30%, rgba(124,247,197,.18), transparent 55%),
                  linear-gradient(180deg, #060911, #0A1020);
      display:flex; align-items:center; justify-content:center;
      transition: opacity .5s ease, transform .5s ease;
    }
    .splash.hide{opacity:0; pointer-events:none; transform: translateY(-8px)}
    .splash .panel{
      width:min(820px, 92vw); border-radius: 28px; border:1px solid rgba(255,255,255,.14);
      background: rgba(10,14,24,.65); backdrop-filter: blur(12px);
      box-shadow: 0 24px 90px rgba(0,0,0,.6); overflow:hidden;
    }
    .splash .panel .in{padding:20px 20px 18px}
    .splash .big{font-size:24px; font-weight:900; letter-spacing:.2px; line-height:1.2}
    .splash .sub{margin-top:10px; color:var(--muted); line-height:1.5}
    .splash .bar{
      height:10px; border-radius:999px; border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06); overflow:hidden; margin-top:14px;
    }
    .splash .bar i{
      display:block; height:100%; width: 0%;
      background: linear-gradient(90deg, rgba(124,247,197,.95), rgba(134,183,255,.95));
      animation: loadbar 1.4s ease forwards;
    }
    @keyframes loadbar{to { width: 100% }}

    /* Research tabs */
    .tabs{display:flex; gap:6px; flex-wrap:wrap; border-bottom:1px solid var(--line); padding-bottom:10px}
    .tabs button{
      background:transparent; border:1px solid transparent; color:var(--muted);
      padding:8px 12px; border-radius:12px; cursor:pointer; font-weight:650; font-size:12px;
    }
    .tabs button:hover{background:rgba(0,0,0,.2); color:var(--txt)}
    .tabs button.active{border-color:var(--accent); color:var(--accent); background:rgba(124,247,197,.08)}
    .tabContent{display:none; padding-top:14px}
    .tabContent.active{display:block}

    /* Event list */
    .elist{display:flex; flex-direction:column; gap:10px}
    .ev{
      border:1px solid var(--line); border-radius: 16px; background: rgba(0,0,0,.14); padding:10px 12px;
    }
    .ev .top{display:flex; align-items:flex-start; justify-content:space-between; gap:12px; flex-wrap:wrap}
    .ev .ttl{font-weight:800; line-height:1.25; font-size:15px}
    .ev .meta{font-size:12px; color:var(--muted); margin-top:6px}
    .ev .srcs{margin-top:8px}
    .ev .desc{margin-top:8px; color:var(--muted); line-height:1.4; font-size:13px}
    .ev .links{margin-top:8px; display:flex; gap:8px; flex-wrap:wrap}
    .ev .score{font-family:var(--mono); font-size:12px; color:var(--muted)}
    .ev .score b{color:var(--txt)}

    /* Collapsibles */
    details{
      border-radius: 16px; border:1px solid var(--line); background: rgba(0,0,0,.12); overflow:hidden; margin:10px 0;
    }
    details summary{
      cursor:pointer; padding:12px 14px; list-style:none;
      display:flex; align-items:center; justify-content:space-between; gap:10px; font-weight:750;
    }
    details summary::-webkit-details-marker{display:none}
    details .inside{padding:12px 14px; border-top:1px solid var(--line); color:var(--muted); line-height:1.5}
    .badgeDot{width:9px; height:9px; border-radius:99px; background: var(--accent); box-shadow: 0 0 0 3px rgba(124,247,197,.16)}
    .badgeDot.warn{background: var(--warn); box-shadow: 0 0 0 3px rgba(255,210,125,.18)}
    .badgeDot.bad{background: var(--bad); box-shadow: 0 0 0 3px rgba(255,125,155,.18)}

    /* Canvas viz */
    .vizWrap{
      border-radius: 18px; border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18); overflow:hidden; min-height:180px;
    }
    canvas{display:block; width:100%; height:auto}

    /* HUD */
    .hud{
      position:fixed; right:14px; bottom:14px; z-index:50; width: 340px;
      border-radius: 22px; border:1px solid rgba(255,255,255,.16);
      background: rgba(10,14,24,.78); backdrop-filter: blur(10px);
      box-shadow: 0 18px 60px rgba(0,0,0,.55); overflow:hidden; user-select:none;
    }
    .hud .hhd{
      padding:10px 12px; display:flex; align-items:center; justify-content:space-between; gap:10px;
      border-bottom:1px solid rgba(255,255,255,.10);
    }
    .hud .hbd{padding:10px 12px}
    .hud .meter{
      height:10px; border-radius:999px; background: rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.10); overflow:hidden;
    }
    .hud .meter > i{
      display:block; height:100%; width: var(--w, 40%);
      background: linear-gradient(90deg, rgba(124,247,197,.95), rgba(134,183,255,.95));
    }
    .hud .mini{display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-top:10px}
    .hud .box{
      border:1px solid rgba(255,255,255,.10); background: rgba(0,0,0,.18);
      border-radius: 16px; padding:9px 10px;
    }
    .hud .box .v{font-weight:800; font-size:16px}
    .hud .box .t{font-size:11px; color:var(--muted)}
    .hud .actions{display:flex; gap:8px; flex-wrap:wrap; margin-top:10px}
    .hud.min{height:48px}
    .hud.min .hbd{display:none}

    /* Footer */
    footer{
      margin-top:18px; padding:14px 16px; border-top:1px solid var(--line);
      color:var(--muted); font-size:12px; line-height:1.5;
    }

    /* Print */
    @media print{
      .topbar,.hud,.splash{display:none !important}
      body{background:#fff !important; color:#000 !important}
      .card, .hero{box-shadow:none !important; border-color:#bbb !important}
      a{color:#000 !important; text-decoration:underline !important}
    }
  </style>
</head>
<body>
  <!--
    ZERO-HARM + ANTI-INVERSION COMMITMENT:
    This platform is designed for research, education, and nonviolent peacebuilding.
    All data remains local. No hidden telemetry. No auto-send. No coercion.
    Adversarial testing is for defense, not offense. Participatory features respect consent and safety.
  -->

  <!-- =========================================================
       RESEARCH NOTE: Splash Screen as Informed Consent
       Theory: Users must understand what they're engaging with.
       Method: Explicit capability disclosure + reset controls.
       Expected outcome: Informed participation, not passive consumption.
  ========================================================== -->
  <div id="splash" class="splash" aria-live="polite">
    <div class="panel">
      <div class="in">
        <div class="big">PhD-Grade Conflict Monitoring Platform üß≠üî¨</div>
        <div class="sub">
          This is a research instrument for interrogating the epistemology of conflict knowledge.
          It analyzes multi-source narratives through seven theoretical lenses: ontology mapping,
          temporal dynamics, provenance tracking, action-confidence matrices, adversarial resilience,
          participatory verification, and performance observability.
        </div>
        <div class="sub tiny">
          Everything runs locally. IndexedDB for persistence. Service Worker for offline capability.
          No external dependencies. No tracking. Optional local-only analytics that you control.
        </div>
        <div class="bar" aria-label="Initializing research environment"><i></i></div>
        <div class="right" style="margin-top:14px">
          <button class="btn primary" id="enterBtn">Enter Research Platform</button>
          <button class="btn" id="resetLocalBtn">Reset All Local Data</button>
        </div>
      </div>
    </div>
  </div>

  <!-- =========================================================
       RESEARCH NOTE: Navigation as Cognitive Scaffold
       Theory: Complex analysis requires clear wayfinding.
       Method: Persistent TOC + contextual search.
  ========================================================== -->
  <header class="topbar">
    <div class="inner">
      <div class="brand">
        <div class="logo" aria-hidden="true"></div>
        <div>
          <div style="font-weight:900; line-height:1.1; font-size:13px">Research-Grade Conflict Monitor</div>
          <div class="tiny muted">Epistemology √ó Peace Informatics</div>
        </div>
      </div>
      <nav class="nav" aria-label="Table of contents">
        <a href="#live">Dashboard</a>
        <a href="#ontology">Ontology</a>
        <a href="#temporal">Temporal</a>
        <a href="#provenance">Provenance</a>
        <a href="#action">Action</a>
        <a href="#adversarial">Red Team</a>
        <a href="#participatory">Community</a>
        <a href="#performance">Performance</a>
        <a href="#sources">Sources</a>
        <a href="#settings">Settings</a>
      </nav>
      <div class="searchBox">
        <input id="search" type="search" placeholder="Search events, analyze patterns‚Ä¶" autocomplete="off" />
      </div>
    </div>
  </header>

  <main class="wrap">
    <!-- =========================================================
         RESEARCH NOTE: Hero as System Status Display
         Theory: Operators need situational awareness before drill-down.
         Method: High-level indicators derived from analytical layers.
    ========================================================== -->
    <section class="hero" id="top">
      <div class="bg" id="parallaxBg" aria-hidden="true"></div>
      <div class="fg">
        <div class="title">
          <div>
            <h1>Multi-Source Conflict Analysis with Epistemological Rigor üåçüõ∞Ô∏è</h1>
            <p>
              This platform treats information divergence as a first-class research signal. When sources disagree,
              it doesn't arbitrate‚Äîit analyzes the structure of disagreement itself. Seven analytical modules
              interrogate different dimensions of the problem: what conceptual frameworks are colliding
              (ontology), how narratives evolve over time (temporal dynamics), whether sources are truly independent
              (provenance), what confidence thresholds justify which actions (actionability), how the system
              performs under adversarial pressure (resilience), how to include community knowledge safely
              (participatory), and where computational limits emerge (performance).
            </p>
          </div>
          <div class="badges">
            <span class="pill" title="Last successful data refresh"><b>Fresh:</b> <span id="freshPill">‚Äî</span></span>
            <span class="pill" title="Average narrative divergence"><b>Divergence:</b> <span id="divPill">‚Äî</span></span>
            <span class="pill" title="Ontological framework diversity"><b>Ontologies:</b> <span id="ontoPill">‚Äî</span></span>
            <span class="pill" title="Source independence score"><b>Independence:</b> <span id="provPill">‚Äî</span></span>
            <span class="pill" title="Cache status"><b>Cache:</b> <span id="cachePill">‚Äî</span></span>
          </div>
        </div>
      </div>
    </section>

    <!-- =========================================================
         RESEARCH LAYER 1: Core Dashboard + Clustering
         Theory: Foundation must remain solid as we add complexity.
         Method: Your original multi-source merge + new confidence math.
    ========================================================== -->
    <div class="row" style="margin-top:14px">
      <section class="col2 card" id="live">
        <div class="hd">
          <h2>Live Dashboard üß™</h2>
          <div class="right">
            <button class="btn primary small" id="refreshBtn">Refresh Sources</button>
            <button class="btn small" id="useCacheBtn">Use Cache</button>
            <button class="btn small" id="exportBtn">Export JSON</button>
          </div>
        </div>
        <div class="bd">
          <div class="grid3">
            <div>
              <label for="region">Region</label>
              <select id="region">
                <option value="world">World</option>
                <option value="europe">Europe</option>
                <option value="mena">Middle East & N. Africa</option>
                <option value="ssa">Sub-Saharan Africa</option>
                <option value="asia">Asia-Pacific</option>
                <option value="americas">Americas</option>
              </select>
            </div>
            <div>
              <label for="window">Time window</label>
              <select id="window">
                <option value="7">Last 7 days</option>
                <option value="14">Last 14 days</option>
                <option value="30">Last 30 days</option>
                <option value="60">Last 60 days</option>
              </select>
            </div>
            <div>
              <label for="minScore">Min confidence</label>
              <select id="minScore">
                <option value="0">Show all</option>
                <option value="0.35">‚â• 0.35</option>
                <option value="0.55" selected>‚â• 0.55</option>
                <option value="0.70">‚â• 0.70</option>
              </select>
            </div>
          </div>

          <div class="sep"></div>

          <div class="grid4" style="font-size:13px">
            <div>
              <div class="tag good"><b id="srcOk">0</b> sources OK</div>
            </div>
            <div>
              <div class="tag warn"><b id="srcPartial">0</b> partial</div>
            </div>
            <div>
              <div class="tag bad"><b id="srcFail">0</b> failed</div>
            </div>
            <div>
              <div class="k">Clusters: <b id="clusterCount">0</b></div>
            </div>
          </div>

          <div class="sep"></div>

          <div class="elist" id="eventList" aria-live="polite"></div>

          <details style="margin-top:14px">
            <summary>
              <span>Clustering algorithm (research notes)</span>
              <span class="badgeDot"></span>
            </summary>
            <div class="inside">
              <p>
                <b>Method:</b> Token-based Jaccard similarity + temporal proximity + location overlap.
                Items cluster when combined score exceeds threshold (0.26). This balances precision
                (too high = missed matches) vs. noise (too low = false merges).
              </p>
              <p style="margin-top:8px">
                <b>Confidence calculation:</b> 55% corroboration weight (more sources = higher confidence),
                35% metadata quality (URLs, timestamps, locations), 10% cohesion bonus (low divergence).
                This penalizes clusters where sources tell fundamentally different stories.
              </p>
              <p style="margin-top:8px">
                <b>Known limitations:</b> Token-based similarity misses semantic equivalence
                ("ceasefire" vs "truce" vs "halt in hostilities"). Future: embedding-based clustering
                with local ONNX models for privacy preservation.
              </p>
            </div>
          </details>
        </div>
      </section>

      <aside class="col card">
        <div class="hd">
          <h2>System Health üå°Ô∏è</h2>
        </div>
        <div class="bd">
          <div class="vizWrap">
            <canvas id="healthViz" width="600" height="280"></canvas>
          </div>
          <div class="sep"></div>
          <div class="tiny">
            <div class="k">Performance budget: <b id="perfBudget">‚Äî</b></div>
            <div class="k">Last clustering: <b id="perfCluster">‚Äî</b></div>
            <div class="k">IndexedDB size: <b id="perfStorage">‚Äî</b></div>
          </div>
        </div>
      </aside>
    </div>

    <!-- =========================================================
         RESEARCH LAYER 2: Ontology Mapping
         Theory: Disagreement often traces to different conceptual frameworks.
         Method: Pattern matching for humanitarian vs military vs political language.
         Expected outcome: Understanding what frameworks are in tension.
    ========================================================== -->
    <section class="card" id="ontology" style="margin-top:14px">
      <div class="hd">
        <h2>Research Module: Ontology Analysis üß¨</h2>
        <div class="right">
          <button class="btn small" id="analyzeOntologyBtn">Analyze Frameworks</button>
        </div>
      </div>
      <div class="bd">
        <div class="tabs">
          <button class="active" data-tab="ontoExplain">Theory</button>
          <button data-tab="ontoResults">Results</button>
          <button data-tab="ontoMatrix">Framework Matrix</button>
        </div>

        <div id="ontoExplain" class="tabContent active">
          <h3>Why Ontology Matters</h3>
          <p>
            When two sources report the same event but use radically different language, they're often
            operating within different <b>ontological frameworks</b>‚Äîdifferent systems for categorizing
            what exists and what matters. A humanitarian organization might describe an airstrike as
            "violation of IHL targeting civilians," while a military source describes it as "neutralization
            of legitimate military target," and a political analyst calls it "escalatory provocation."
          </p>
          <p style="margin-top:12px">
            These aren't just word choices. They reflect different:
          </p>
          <ul style="margin-left:20px; margin-top:8px">
            <li><b>Legal frameworks</b> (international humanitarian law vs. rules of engagement)</li>
            <li><b>Moral priorities</b> (civilian protection vs. military necessity vs. political strategy)</li>
            <li><b>Epistemic standards</b> (verified casualties vs. estimated combatants vs. attributed intent)</li>
          </ul>
          <p style="margin-top:12px">
            This module detects which frameworks each source employs by analyzing vocabulary patterns,
            then surfaces where framework collisions create apparent factual disagreement that's actually
            deeper conceptual incommensurability.
          </p>

          <details style="margin-top:12px">
            <summary>
              <span>Technical implementation</span>
              <span class="badgeDot warn"></span>
            </summary>
            <div class="inside">
              <p>
                Pattern matching against three vocabulary sets: (1) humanitarian law terms (IHL, Geneva Conventions,
                protected persons, proportionality), (2) military operational terms (neutralize, target, combatant,
                collateral, ROE), (3) political framing terms (aggression, provocation, retaliation, legitimacy).
              </p>
              <p style="margin-top:8px">
                Each cluster gets an ontology profile vector. High diversity = framework collision.
                This explains divergence that's not measurement error but conceptual incommensurability.
              </p>
            </div>
          </details>
        </div>

        <div id="ontoResults" class="tabContent">
          <div id="ontoResultsBox" class="muted">
            Run analysis to see results.
          </div>
        </div>

        <div id="ontoMatrix" class="tabContent">
          <div class="vizWrap">
            <canvas id="ontoCanvas" width="700" height="400"></canvas>
          </div>
          <div class="sep"></div>
          <div class="tiny muted">
            Matrix shows framework overlap across clusters. Bright cells = high usage of that framework.
            Clusters using multiple frameworks simultaneously indicate conceptual tension.
          </div>
        </div>
      </div>
    </section>

    <!-- =========================================================
         RESEARCH LAYER 3: Temporal Dynamics
         Theory: Narrative convergence speed reveals information ecosystem pressure.
         Method: Track divergence velocity and acceleration over time.
    ========================================================== -->
    <section class="card" id="temporal" style="margin-top:14px">
      <div class="hd">
        <h2>Research Module: Narrative Velocity & Acceleration üìà</h2>
        <div class="right">
          <button class="btn small" id="trackTemporalBtn">Track Evolution</button>
        </div>
      </div>
      <div class="bd">
        <div class="tabs">
          <button class="active" data-tab="tempExplain">Theory</button>
          <button data-tab="tempViz">Visualization</button>
          <button data-tab="tempAlerts">Velocity Alerts</button>
        </div>

        <div id="tempExplain" class="tabContent active">
          <h3>Why Temporal Dynamics Matter</h3>
          <p>
            Early conflict reports are often contradictory simply because information is scarce and chaotic.
            Over days, as more sources gather data, narratives typically <b>converge naturally</b> toward
            consensus. But propaganda exploits this same convergence process‚Äîcoordinated actors can drive
            artificial consensus by flooding the zone with aligned messaging.
          </p>
          <p style="margin-top:12px">
            The question this module asks: <b>How fast are narratives converging, and is that speed natural?</b>
          </p>
          <p style="margin-top:12px">
            We track two metrics:
          </p>
          <ul style="margin-left:20px; margin-top:8px">
            <li><b>Divergence velocity:</b> Rate of change in disagreement (Œîdivergence / Œîtime)</li>
            <li><b>Divergence acceleration:</b> Whether convergence is speeding up or steady (ŒîŒîdivergence / ŒîŒîtime)</li>
          </ul>
          <p style="margin-top:12px">
            Natural convergence: gradual, decelerating (starts fast, slows as consensus emerges). Suspicious convergence:
            sudden, accelerating (sources flip positions rapidly, often in coordinated waves).
          </p>

          <details style="margin-top:12px">
            <summary>
              <span>Mathematical formulation</span>
              <span class="badgeDot warn"></span>
            </summary>
            <div class="inside">
              <pre>Let D(t) = divergence score at time t
velocity = (D(t) - D(t-1)) / Œît
acceleration = (velocity(t) - velocity(t-1)) / Œît

Alert conditions:
- If |velocity| > threshold AND acceleration > 0 ‚Üí "Rapid convergence"
- If multiple clusters show synchronized velocity spikes ‚Üí "Coordinated pressure"</pre>
            </div>
          </details>
        </div>

        <div id="tempViz" class="tabContent">
          <div class="vizWrap">
            <canvas id="tempCanvas" width="800" height="360"></canvas>
          </div>
          <div class="sep"></div>
          <div class="tiny muted">
            Graph shows divergence scores over time for top clusters. Steep drops = rapid convergence.
            Multiple parallel drops = potential coordination.
          </div>
        </div>

        <div id="tempAlerts" class="tabContent">
          <div id="tempAlertsBox" class="muted">
            No temporal tracking data yet. Click "Track Evolution" and refresh periodically.
          </div>
        </div>
      </div>
    </section>

    <!-- =========================================================
         RESEARCH LAYER 4: Provenance & Source Independence
         Theory: Corroboration only matters if sources are truly independent.
         Method: Build dependency graph, adjust confidence by independence estimate.
    ========================================================== -->
    <section class="card" id="provenance" style="margin-top:14px">
      <div class="hd">
        <h2>Research Module: Source Independence Mapping üï∏Ô∏è</h2>
        <div class="right">
          <button class="btn small" id="mapProvenanceBtn">Build Graph</button>
        </div>
      </div>
      <div class="bd">
        <div class="tabs">
          <button class="active" data-tab="provExplain">Theory</button>
          <button data-tab="provGraph">Dependency Graph</button>
          <button data-tab="provScores">Independence Scores</button>
        </div>

        <div id="provExplain" class="tabContent active">
          <h3>The Independence Problem</h3>
          <p>
            Your redundancy model assumes more sources = more confidence. But if three news outlets all cite
            the same wire service, you have <b>amplification, not corroboration</b>. If two NGOs rely on the
            same local partner network, their agreement partly reflects shared infrastructure, not independent
            verification.
          </p>
          <p style="margin-top:12px">
            This is the hardest problem in multi-source analysis: <b>How independent are your sources really?</b>
          </p>
          <p style="margin-top:12px">
            This module attempts to estimate source dependencies by:
          </p>
          <ul style="margin-left:20px; margin-top:8px">
            <li>Detecting common URLs (multiple sources citing the same origin)</li>
            <li>Tracking organizational relationships (NGO field office structures)</li>
            <li>Timing analysis (stories appearing simultaneously suggest shared feeds)</li>
            <li>Language fingerprinting (identical phrasing indicates copying)</li>
          </ul>
          <p style="margin-top:12px">
            The system then adjusts confidence scores: high-independence clusters get bonuses, low-independence
            get penalties. A three-source cluster where all sources are independent is stronger than a five-source
            cluster where four are downstream of one.
          </p>

          <details style="margin-top:12px">
            <summary>
              <span>Estimation methodology</span>
              <span class="badgeDot bad"></span>
            </summary>
            <div class="inside">
              <p>
                This is necessarily <b>heuristic</b>. True provenance tracking requires metadata that sources
                often don't provide (who interviewed whom, what documents were consulted, which field reports
                fed into which summaries). We use proxies:
              </p>
              <ul style="margin-left:20px; margin-top:8px">
                <li>URL overlap ‚Üí dependency edge (weight = 1.0)</li>
                <li>Same-hour publication ‚Üí possible shared feed (weight = 0.4)</li>
                <li>High text similarity ‚Üí potential copying (weight = 0.6)</li>
              </ul>
              <p style="margin-top:8px">
                Confidence adjustment: independence_score = 1 - (Œ£ edge_weights / possible_edges).
                Final confidence *= (0.7 + 0.3 * independence_score).
              </p>
            </div>
          </details>
        </div>

        <div id="provGraph" class="tabContent">
          <div class="vizWrap">
            <canvas id="provCanvas" width="700" height="420"></canvas>
          </div>
          <div class="sep"></div>
          <div class="tiny muted">
            Network graph: nodes are sources, edges are dependencies. Thicker edges = stronger dependency.
            Isolated nodes = independent sources (high value). Dense clusters = potential echo chambers.
          </div>
        </div>

        <div id="provScores" class="tabContent">
          <div id="provScoresBox" class="muted">
            Run provenance analysis to see independence scores per cluster.
          </div>
        </div>
      </div>
    </section>

    <!-- =========================================================
         RESEARCH LAYER 5: Action-Risk-Confidence Matrix
         Theory: Different actions need different evidence thresholds.
         Method: Model action types with risk profiles, calculate required confidence.
    ========================================================== -->
    <section class="card" id="action" style="margin-top:14px">
      <div class="hd">
        <h2>Research Module: Actionability & Confidence Thresholds üéØ</h2>
        <div class="right">
          <button class="btn small" id="calculateThresholdsBtn">Calculate Thresholds</button>
        </div>
      </div>
      <div class="bd">
        <div class="tabs">
          <button class="active" data-tab="actExplain">Theory</button>
          <button data-tab="actMatrix">Risk-Confidence Matrix</button>
          <button data-tab="actPlans">Generated Action Plans</button>
        </div>

        <div id="actExplain" class="tabContent active">
          <h3>The Threshold Problem</h3>
          <p>
            Not all actions require the same level of certainty. Donating $20 to an established humanitarian
            organization working in a conflict zone is a low-risk action‚Äîeven if specific details are unclear,
            the general need is real and the org has infrastructure to deploy aid responsibly. But calling
            your senator to demand sanctions against specific individuals or entities is a high-risk action‚Äîif
            your factual claims are wrong, you're pressuring for harmful policy.
          </p>
          <p style="margin-top:12px">
            This module formalizes the relationship between <b>action risk</b>, <b>available evidence</b>,
            and <b>responsible threshold</b>.
          </p>
          <p style="margin-top:12px">
            Action taxonomy with risk levels:
          </p>
          <ul style="margin-left:20px; margin-top:8px">
            <li><b>Very Low Risk:</b> Support general humanitarian relief (threshold: 0.35)</li>
            <li><b>Low Risk:</b> Share careful summary citing multiple sources (threshold: 0.50)</li>
            <li><b>Medium Risk:</b> Join organized advocacy with clear asks (threshold: 0.65)</li>
            <li><b>High Risk:</b> Pressure representatives for specific policy (threshold: 0.80)</li>
            <li><b>Very High Risk:</b> Amplify claims about named individuals (threshold: 0.90)</li>
          </ul>
          <p style="margin-top:12px">
            The platform calculates whether each cluster meets the threshold for each action type, then
            generates appropriate plans. If confidence is 0.62, you get medium-risk options but not high-risk.
          </p>

          <details style="margin-top:12px">
            <summary>
              <span>Mathematical formulation</span>
              <span class="badgeDot warn"></span>
            </summary>
            <div class="inside">
              <pre>For cluster C with confidence score S:
available_actions = { A | threshold(A) ‚â§ S }

Risk function R(A):
R(A) = potential_harm(A) / reversibility(A)

Threshold derivation:
threshold(A) = min_confidence where E[harm | wrong] < acceptable_risk

This models precautionary principle: as irreversibility increases, evidence bar rises.</pre>
            </div>
          </details>
        </div>

        <div id="actMatrix" class="tabContent">
          <div class="vizWrap">
            <canvas id="actCanvas" width="700" height="380"></canvas>
          </div>
          <div class="sep"></div>
          <div class="tiny muted">
            Heatmap: rows = action types, columns = confidence levels. Color intensity = appropriateness.
            Dark green = action justified, red = action not justified, yellow = borderline.
          </div>
        </div>

        <div id="actPlans" class="tabContent">
          <label for="planCluster">Select cluster for action planning:</label>
          <select id="planCluster"></select>
          <div class="sep"></div>
          <div id="actPlansBox" class="muted">
            Select a cluster above.
          </div>
        </div>
      </div>
    </section>

    <!-- =========================================================
         RESEARCH LAYER 6: Adversarial Resilience Testing
         Theory: Multi-source systems can be defeated by coordinated deception.
         Method: Inject synthetic false narratives, measure detection capability.
    ========================================================== -->
    <section class="card" id="adversarial" style="margin-top:14px">
      <div class="hd">
        <h2>Research Module: Red Team Simulation üõ°Ô∏è</h2>
        <div class="right">
          <button class="btn danger small" id="runRedTeamBtn">Launch Attack Simulation</button>
        </div>
      </div>
      <div class="bd">
        <div class="tabs">
          <button class="active" data-tab="advExplain">Theory</button>
          <button data-tab="advScenarios">Attack Scenarios</button>
          <button data-tab="advResults">Simulation Results</button>
        </div>

        <div id="advExplain" class="tabContent active">
          <h3>The Adversarial Threat Model</h3>
          <p>
            Your redundancy model assumes sources are acting in good faith, possibly with different perspectives,
            but attempting to report reality. But what if an adversary <b>understands your algorithm</b> and
            designs attacks to defeat it?
          </p>
          <p style="margin-top:12px">
            Possible attacks:
          </p>
          <ul style="margin-left:20px; margin-top:8px">
            <li><b>Coordinated fabrication:</b> Plant false story across multiple "independent" sources simultaneously</li>
            <li><b>Source impersonation:</b> Create fake outlets mimicking trusted sources' style</li>
            <li><b>Timing manipulation:</b> Stage false reports to create artificial convergence patterns</li>
            <li><b>Ontology pollution:</b> Inject language from multiple frameworks to appear balanced</li>
            <li><b>Provenance obscuring:</b> Disguise dependency relationships to fake independence</li>
          </ul>
          <p style="margin-top:12px">
            This module runs <b>controlled attack simulations</b> where synthetic false narratives are injected
            into your real data, then measures whether your clustering, confidence scoring, and divergence
            detection would flag them as suspicious.
          </p>
          <p style="margin-top:12px">
            <b>CRITICAL SAFETY NOTE:</b> Simulated attacks are clearly marked and stored separately. They never
            contaminate real data. After simulation, you can inspect which attacks succeeded (false negatives)
            and which your system detected (true positives). This is research, not operational deception.
          </p>

          <details style="margin-top:12px">
            <summary>
              <span>Ethical safeguards</span>
              <span class="badgeDot bad"></span>
            </summary>
            <div class="inside">
              <p>
                Red teaming must never harm real analysis. All simulated attacks:
              </p>
              <ul style="margin-left:20px; margin-top:8px">
                <li>Are clearly labeled as synthetic in storage</li>
                <li>Use obviously fictional location/entity names</li>
                <li>Cannot be exported with real data</li>
                <li>Are automatically purged after 24 hours</li>
                <li>Are never run without explicit user initiation</li>
              </ul>
              <p style="margin-top:8px">
                Purpose is defensive: understand your system's limits so you know when to distrust it.
              </p>
            </div>
          </details>
        </div>

        <div id="advScenarios" class="tabContent">
          <h4>Select Attack Scenario:</h4>
          <div class="sep"></div>
          <div style="display:flex; flex-direction:column; gap:10px">
            <label>
              <input type="radio" name="advScenario" value="coordinated" checked>
              <b>Coordinated Fabrication:</b> Three fake sources report the same false event within 2 hours
            </label>
            <label>
              <input type="radio" name="advScenario" value="impersonation">
              <b>Source Impersonation:</b> Fake outlet mimics trusted source's language patterns
            </label>
            <label>
              <input type="radio" name="advScenario" value="timing">
              <b>Timing Manipulation:</b> Stage artificial convergence (divergent ‚Üí rapid agreement)
            </label>
            <label>
              <input type="radio" name="advScenario" value="ontology">
              <b>Ontology Pollution:</b> Mix frameworks to appear balanced (humanitarian + military terms)
            </label>
            <label>
              <input type="radio" name="advScenario" value="provenance">
              <b>Provenance Obscuring:</b> Multiple sources hide their shared origin
            </label>
          </div>
          <div class="sep"></div>
          <div class="tiny muted">
            Simulations use fictional data (locations: "Testistan", sources: "Example News Network").
            Results show whether your system would detect the attack pattern.
          </div>
        </div>

        <div id="advResults" class="tabContent">
          <div id="advResultsBox" class="muted">
            Run a simulation to see results.
          </div>
        </div>
      </div>
    </section>

    <!-- =========================================================
         RESEARCH LAYER 7: Participatory Verification
         Theory: Ground-truth knowledge often doesn't fit institutional schemas.
         Method: Community contribution pathway with consent and safety controls.
    ========================================================== -->
    <section class="card" id="participatory" style="margin-top:14px">
      <div class="hd">
        <h2>Research Module: Community Knowledge Pathway ü§ù</h2>
        <div class="right">
          <button class="btn small" id="communityGuidelinesBtn">Safety Guidelines</button>
        </div>
      </div>
      <div class="bd">
        <div class="tabs">
          <button class="active" data-tab="partExplain">Theory</button>
          <button data-tab="partSubmit">Submit Knowledge</button>
          <button data-tab="partReview">Review Submissions</button>
        </div>

        <div id="partExplain" class="tabContent active">
          <h3>The Representation Problem</h3>
          <p>
            Your platform aggregates institutional sources: news organizations, humanitarian agencies, research
            datasets. But people living through conflicts have knowledge that may never appear in these channels‚Äîeither
            because reporting is too dangerous, or their voices aren't considered "authoritative," or what they
            know doesn't fit report templates.
          </p>
          <p style="margin-top:12px">
            This creates an <b>epistemic injustice</b>: the people with the most direct knowledge have the least
            representation in information systems that claim to describe their reality.
          </p>
          <p style="margin-top:12px">
            This module attempts to address this by creating a pathway for community-contributed knowledge that:
          </p>
          <ul style="margin-left:20px; margin-top:8px">
            <li>Respects contributor safety (optional anonymization, no forced metadata)</li>
            <li>Maintains contributor control (consent for use, ability to retract)</li>
            <li>Weights appropriately (lived experience has epistemic value different from institutional reports)</li>
            <li>Avoids extraction (communities benefit from analysis, not just provide data)</li>
          </ul>
          <p style="margin-top:12px">
            <b>CRITICAL SAFETY:</b> Contributors in conflict zones face real risks. This system never requires
            identifying information, never transmits location data automatically, and stores contributions locally
            with encryption. Export features explicitly warn about de-anonymization risks.
          </p>

          <details style="margin-top:12px">
            <summary>
              <span>Ethical framework</span>
              <span class="badgeDot warn"></span>
            </summary>
            <div class="inside">
              <p>
                Based on principles from participatory action research and Indigenous data sovereignty:
              </p>
              <ul style="margin-left:20px; margin-top:8px">
                <li><b>CARE Principles:</b> Collective benefit, Authority to control, Responsibility, Ethics</li>
                <li><b>Informed consent:</b> Clear explanation of how contributions are used</li>
                <li><b>Reversibility:</b> Contributors can retract knowledge at any time</li>
                <li><b>Non-extraction:</b> Analysis results shared back to communities</li>
              </ul>
            </div>
          </details>
        </div>

        <div id="partSubmit" class="tabContent">
          <p class="tiny muted" style="margin-bottom:12px">
            <b>Safety first:</b> If you're submitting from a conflict zone, use VPN/Tor. This platform stores locally,
            but any export could be intercepted. Consider carefully before sharing sensitive information.
          </p>

          <label for="partType">Type of knowledge:</label>
          <select id="partType">
            <option value="observation">Direct observation (what I witnessed)</option>
            <option value="testimony">Personal testimony (what happened to me/my community)</option>
            <option value="analysis">Community analysis (what we collectively understand)</option>
            <option value="correction">Correction (errors in institutional reporting)</option>
          </select>

          <label for="partLocation">Location (optional, can be vague like "northern region"):</label>
          <input id="partLocation" placeholder="Leave blank or use general area">

          <label for="partTime">Time period (optional):</label>
          <input id="partTime" type="text" placeholder="e.g., 'December 2025' or 'last month'">

          <label for="partContent">What you want to share:</label>
          <textarea id="partContent" rows="6" placeholder="Describe what you know. You control how much detail to include."></textarea>

          <div class="sep"></div>

          <label style="display:flex; align-items:center; gap:8px; margin:12px 0">
            <input type="checkbox" id="partConsent">
            <span class="tiny">I understand this is stored locally on my device and I can delete it anytime.</span>
          </label>

          <label style="display:flex; align-items:center; gap:8px; margin:12px 0">
            <input type="checkbox" id="partAnon">
            <span class="tiny">Keep this anonymous (recommended if safety is a concern).</span>
          </label>

          <div class="right" style="margin-top:12px">
            <button class="btn primary" id="submitPartBtn">Submit to Local Storage</button>
            <button class="btn" id="clearPartFormBtn">Clear Form</button>
          </div>
        </div>

        <div id="partReview" class="tabContent">
          <div id="partReviewBox" class="muted">
            No community submissions yet.
          </div>
          <div class="sep"></div>
          <button class="btn danger small" id="clearAllPartBtn">Clear All Submissions</button>
        </div>
      </div>
    </section>

    <!-- =========================================================
         RESEARCH LAYER 8: Performance Observatory
         Theory: Understand where computational limits emerge as system scales.
         Method: Profile key operations, estimate scaling curves.
    ========================================================== -->
    <section class="card" id="performance" style="margin-top:14px">
      <div class="hd">
        <h2>Research Module: Performance & Scalability Analysis üìä</h2>
        <div class="right">
          <button class="btn small" id="runPerfTestBtn">Run Load Test</button>
        </div>
      </div>
      <div class="bd">
        <div class="tabs">
          <button class="active" data-tab="perfExplain">Theory</button>
          <button data-tab="perfMetrics">Current Metrics</button>
          <button data-tab="perfScaling">Scaling Curves</button>
        </div>

        <div id="perfExplain" class="tabContent active">
          <h3>The Scalability Question</h3>
          <p>
            Your current architecture runs entirely client-side, which is brilliant for privacy and offline capability
            but has computational limits. As you scale from monitoring 2-3 conflicts with 50 events to monitoring
            dozens of conflicts with thousands of events, something breaks first. Understanding <b>what breaks and when</b>
            is crucial for system design.
          </p>
          <p style="margin-top:12px">
            This module profiles key operations and estimates scaling behavior:
          </p>
          <ul style="margin-left:20px; margin-top:8px">
            <li><b>Clustering:</b> O(n¬≤) naive implementation ‚Üí what's practical limit?</li>
            <li><b>Storage:</b> IndexedDB has limits (50MB typical, varies by browser)</li>
            <li><b>Rendering:</b> DOM updates become slow with >500 items visible</li>
            <li><b>Analysis:</b> Ontology/temporal/provenance layers add computational cost</li>
          </ul>
          <p style="margin-top:12px">
            Performance tests inject synthetic datasets of varying sizes, measure completion times, and extrapolate
            to predict where bottlenecks emerge. Results guide architectural decisions (e.g., when to move to
            Web Workers, when hierarchical clustering becomes necessary).
          </p>

          <details style="margin-top:12px">
            <summary>
              <span>Measurement methodology</span>
              <span class="badgeDot warn"></span>
            </summary>
            <div class="inside">
              <pre>Test suite:
1. Generate synthetic events (100, 500, 1000, 2500, 5000)
2. Time clustering operation (pure JS, main thread)
3. Time ontology analysis (pattern matching across all items)
4. Time provenance graph construction (O(n¬≤) worst case)
5. Time DOM rendering (innerHTML updates)
6. Measure IndexedDB write throughput

Scaling curve: fit power law to (n, time) data points.
Threshold: predict n where operation exceeds 2 seconds (UX break)</pre>
            </div>
          </details>
        </div>

        <div id="perfMetrics" class="tabContent">
          <div id="perfMetricsBox" class="muted">
            Run load test to collect metrics.
          </div>
        </div>

        <div id="perfScaling" class="tabContent">
          <div class="vizWrap">
            <canvas id="perfCanvas" width="700" height="380"></canvas>
          </div>
          <div class="sep"></div>
          <div class="tiny muted">
            Log-log plot: x-axis = dataset size, y-axis = operation time. Linear in log-log space indicates
            power-law scaling. Steeper slope = worse scaling. Red zone = exceeds 2s (user experience breaks).
          </div>
        </div>
      </div>
    </section>

    <!-- =========================================================
         Core Infrastructure: Sources & Settings
    ========================================================== -->
    <section class="card" id="sources" style="margin-top:14px">
      <div class="hd">
        <h2>Data Sources & Connectors üîå</h2>
        <div class="right">
          <button class="btn small" id="addCustomSourceBtn">Add Custom Source</button>
          <button class="btn danger small" id="clearKeysBtn">Clear Stored Keys</button>
        </div>
      </div>
      <div class="bd">
        <div class="tiny muted" style="margin-bottom:12px; line-height:1.5">
          Research-grade monitoring requires diverse, independent sources. This platform includes public connectors
          (GDELT, ReliefWeb) and supports custom endpoints + manual imports for CORS-blocked datasets.
        </div>
        <div id="sourceCards" class="grid2"></div>
      </div>
    </section>

    <section class="card" id="settings" style="margin-top:14px">
      <div class="hd">
        <h2>Settings & Privacy Controls ‚öôÔ∏è</h2>
        <div class="right">
          <button class="btn small" id="swStatusBtn">SW Status</button>
          <button class="btn danger small" id="wipeAllBtn">Wipe All Data</button>
        </div>
      </div>
      <div class="bd">
        <div class="grid3">
          <div>
            <h4>Offline & Caching</h4>
            <div class="sep"></div>
            <label style="display:flex; align-items:center; gap:8px">
              <input type="checkbox" id="offlineCacheToggle">
              <span class="tiny">Cache results for offline use</span>
            </label>
            <label style="display:flex; align-items:center; gap:8px; margin-top:8px">
              <input type="checkbox" id="autoRefreshToggle">
              <span class="tiny">Auto-refresh on open</span>
            </label>
          </div>
          <div>
            <h4>Local Analytics</h4>
            <div class="sep"></div>
            <label style="display:flex; align-items:center; gap:8px">
              <input type="checkbox" id="localAnalyticsToggle">
              <span class="tiny">Track usage locally (never sent)</span>
            </label>
            <div class="sep"></div>
            <button class="btn small" id="resetAnalyticsBtn">Reset Analytics</button>
          </div>
          <div>
            <h4>Safety</h4>
            <div class="sep"></div>
            <div class="tiny muted" style="line-height:1.5">
              ‚Ä¢ No auto-send<br>
              ‚Ä¢ Input sanitized<br>
              ‚Ä¢ Rate limited<br>
              ‚Ä¢ No telemetry<br>
              ‚Ä¢ Red-team simulations marked synthetic<br>
              ‚Ä¢ Community data encrypted locally
            </div>
          </div>
        </div>
      </div>
    </section>

    <footer>
      <b>Zero-Harm & Anti-Inversion Commitment:</b> This platform is a research instrument for peace informatics.
      It interrogates information quality without coercion, stores data locally without telemetry, and supports
      nonviolent action pathways without pressure. Adversarial testing is defensive. Community knowledge pathways
      respect safety and consent. All analysis remains under user control. üïäÔ∏è
      <div class="faint" style="margin-top:8px">
        No secrets stored. No auto-send. Clear wipe controls. Simulated attacks clearly marked. Export warnings included.
      </div>
    </footer>
  </main>

  <!-- =========================================================
       HUD: Research Progress Tracker
  ========================================================== -->
  <div class="hud" id="hud" role="region" aria-label="Research HUD">
    <div class="hhd">
      <div style="display:flex; align-items:center; gap:10px">
        <div class="badgeDot"></div>
        <div>
          <div style="font-weight:900; font-size:13px">Research HUD</div>
          <div style="font-size:10px; color:var(--faint)">Local-only ‚Ä¢ drag to move</div>
        </div>
      </div>
      <button class="btn small" id="minHudBtn">‚Äî</button>
    </div>
    <div class="hbd">
      <div class="tiny muted">Analysis Progress</div>
      <div class="meter"><i id="momentumBar" style="--w: 25%"></i></div>

      <div class="mini">
        <div class="box">
          <div class="v" id="hudClusters">0</div>
          <div class="t">Clusters</div>
        </div>
        <div class="box">
          <div class="v" id="hudRefreshes">0</div>
          <div class="t">Refreshes</div>
        </div>
        <div class="box">
          <div class="v" id="hudModules">0/7</div>
          <div class="t">Modules Run</div>
        </div>
        <div class="box">
          <div class="v" id="hudStreak">0</div>
          <div class="t">Day Streak</div>
        </div>
      </div>

      <div class="actions">
        <button class="btn primary small" id="hudQuickRefresh">Quick Refresh</button>
        <button class="btn small" id="hudSnapshot">Snapshot</button>
      </div>
    </div>
  </div>

  <noscript>
    <div style="max-width:900px;margin:18px auto;padding:12px 14px;border:1px solid #888;border-radius:14px;background:#fff;color:#000">
      <b>JavaScript Required:</b> This research platform needs JS for analysis, offline storage, and visualization.
    </div>
  </noscript>

  <script>
    /* =========================================================
       RESEARCH PLATFORM: JavaScript Implementation
       Theory: Complex analysis requires clean abstractions.
       Method: Modular architecture with clear interfaces.
    ========================================================== */

    // ==== Utility Layer ====
    const Safe = (() => {
      const escape = (s) => String(s ?? "")
        .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
        .replaceAll('"',"&quot;").replaceAll("'","&#39;");
      const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
      const limiter = (() => {
        const state = { last: 0, tokens: 4, refillMs: 4000, max: 4 };
        return {
          allow() {
            const t = Date.now(), delta = t - state.last;
            if (delta > state.refillMs) {
              state.tokens = Math.min(state.max, state.tokens + Math.floor(delta / state.refillMs));
              state.last = t;
            }
            if (state.tokens <= 0) return false;
            state.tokens -= 1;
            return true;
          }
        };
      })();
      const hash = (text) => {
        let h = 2166136261;
        for (let i=0;i<text.length;i++){
          h ^= text.charCodeAt(i);
          h = Math.imul(h, 16777619);
        }
        return (h>>>0).toString(16);
      };
      return { escape, clamp, limiter, hash };
    })();

    // ==== Storage Layer ====
    const DB = (() => {
      const DB_NAME = "phd_conflict_monitor", DB_VER = 1;
      let db = null;

      function open(){
        return new Promise((resolve, reject) => {
          const req = indexedDB.open(DB_NAME, DB_VER);
          req.onupgradeneeded = () => {
            const d = req.result;
            const mk = (name) => {
              if(!d.objectStoreNames.contains(name)) d.createObjectStore(name, { keyPath:"id" });
            };
            mk("settings"); mk("cache"); mk("sources"); mk("analytics");
            mk("ontology"); mk("temporal"); mk("provenance"); mk("actions");
            mk("adversarial"); mk("participatory"); mk("performance");
          };
          req.onsuccess = () => { db = req.result; resolve(db); };
          req.onerror = () => reject(req.error);
        });
      }

      function tx(store, mode="readonly"){
        if(!db) throw new Error("DB not open");
        return db.transaction(store, mode).objectStore(store);
      }

      function put(store, val){
        return new Promise((resolve,reject)=>{
          const r = tx(store, "readwrite").put(val);
          r.onsuccess=()=>resolve(true);
          r.onerror=()=>reject(r.error);
        });
      }
      function get(store, id){
        return new Promise((resolve,reject)=>{
          const r = tx(store).get(id);
          r.onsuccess=()=>resolve(r.result ?? null);
          r.onerror=()=>reject(r.error);
        });
      }
      function all(store){
        return new Promise((resolve,reject)=>{
          const r = tx(store).getAll();
          r.onsuccess=()=>resolve(r.result ?? []);
          r.onerror=()=>reject(r.error);
        });
      }
      function del(store, id){
        return new Promise((resolve,reject)=>{
          const r = tx(store, "readwrite").delete(id);
          r.onsuccess=()=>resolve(true);
          r.onerror=()=>reject(r.error);
        });
      }
      async function wipeAll(){
        if(db) db.close();
        await new Promise((resolve,reject)=>{
          const r = indexedDB.deleteDatabase(DB_NAME);
          r.onsuccess=()=>resolve(true);
          r.onerror=()=>reject(r.error);
          r.onblocked=()=>resolve(true);
        });
        db = null;
      }

      return { open, put, get, all, del, wipeAll };
    })();

    // ==== Service Worker ====
    async function registerSW(){
      const code = `
        const CACHE = "phd-conflict-v1";
        self.addEventListener("install", (e) => {
          e.waitUntil((async () => {
            const cache = await caches.open(CACHE);
            try { await cache.addAll([self.registration.scope]); } catch{}
            self.skipWaiting();
          })());
        });
        self.addEventListener("activate", (e) => {
          e.waitUntil((async () => {
            const keys = await caches.keys();
            await Promise.all(keys.map(k => (k===CACHE)?null:caches.delete(k)));
            self.clients.claim();
          })());
        });
        self.addEventListener("fetch", (e) => {
          if (e.request.mode === "navigate") {
            e.respondWith((async () => {
              const cache = await caches.open(CACHE);
              const cached = await cache.match(self.registration.scope);
              try {
                const fresh = await fetch(e.request);
                cache.put(self.registration.scope, fresh.clone());
                return fresh;
              } catch {
                return cached || new Response("Offline", {status: 503});
              }
            })());
          }
        });
      `;
      try{
        const blob = new Blob([code], {type:"text/javascript"});
        const url = URL.createObjectURL(blob);
        const reg = await navigator.serviceWorker.register(url, {scope: "./"});
        return reg;
      }catch(e){
        return null;
      }
    }

    // ==== Data Connectors ====
    const CONNECTORS = [
      {
        id: "gdelt",
        name: "GDELT 2.1 (Global news signal)",
        kind: "public",
        hint: "Often CORS-friendly. Broad media coverage but not ground-truth.",
        enabledByDefault: true,
        fields: [],
        async fetch({windowDays, region}){
          const now = new Date(), past = new Date(Date.now() - windowDays*24*3600*1000);
          const fmt = (d)=> d.toISOString().slice(0,10).replaceAll("-","");
          const start = fmt(past), end = fmt(now);
          const regionQ = ({
            world:"", europe:"theme:EUROPE", mena:"theme:MIDDLEEAST",
            ssa:"theme:AFRICA", asia:"theme:ASIA", americas:"theme:AMERICAS"
          })[region] || "";
          const q = "(conflict OR ceasefire OR clashes OR humanitarian)" + (regionQ ? " AND " + regionQ : "");
          const url = "https://api.gdeltproject.org/api/v2/doc/doc?format=json&mode=ArtList"
            + "&query=" + encodeURIComponent(q)
            + "&startdatetime=" + start + "000000"
            + "&enddatetime=" + end + "235959"
            + "&maxrecords=80&sort=HybridRel";
          const r = await fetch(url, {mode:"cors"});
          if(!r.ok) throw new Error("GDELT fetch failed");
          const j = await r.json();
          return (j?.articles || []).slice(0,80).map(a => ({
            title: a.title || "Untitled",
            date: a.seendate || a.datetime || "",
            location: (a.sourceCountry || "") + (a.location ? " ‚Ä¢ " + a.location : ""),
            summary: a.snippet || a.description || "",
            url: a.url || "",
            tags: ["news"]
          }));
        },
        normalize(item){
          return {
            title: String(item.title || "").slice(0, 220),
            time: parseTime(item.date),
            location: String(item.location || ""),
            summary: String(item.summary || "").slice(0, 900),
            url: safeUrl(item.url),
            tags: item.tags || [],
            source: "GDELT",
          };
        }
      },
      {
        id: "reliefweb",
        name: "ReliefWeb (Humanitarian signal)",
        kind: "public",
        hint: "UN OCHA. Excellent for needs-based perspectives.",
        enabledByDefault: true,
        fields: [],
        async fetch({windowDays, region}){
          const from = new Date(Date.now() - windowDays*24*3600*1000).toISOString();
          const regionMap = {
            world: null, europe: "europe", mena: "middle-east-and-north-africa",
            ssa: "sub-saharan-africa", asia: "asia-and-the-pacific", americas: "americas"
          };
          const regionSlug = regionMap[region];
          const filter = [{field:"date.created", value:{from}}];
          if(regionSlug) filter.push({field:"primary_country.region", value:[regionSlug]});
          const body = {
            query: { value: "conflict OR displacement OR humanitarian" },
            filter: filter.length ? {operator:"AND", conditions:filter} : undefined,
            sort: ["date.created:desc"],
            limit: 60,
            fields: ["title","body","date","url","primary_country"]
          };
          const r = await fetch("https://api.reliefweb.int/v1/reports", {
            method:"POST",
            headers: {"Content-Type":"application/json"},
            body: JSON.stringify(body)
          });
          if(!r.ok) throw new Error("ReliefWeb failed");
          const j = await r.json();
          return (j?.data || []).slice(0,60).map(d => ({
            title: d?.fields?.title || "Untitled",
            date: d?.fields?.date?.created || "",
            location: (d?.fields?.primary_country?.map(c=>c.name).join(", ") || ""),
            summary: stripHtml(d?.fields?.body || "").slice(0, 600),
            url: d?.fields?.url || "",
            tags: ["humanitarian"]
          }));
        },
        normalize(item){
          return {
            title: String(item.title || "").slice(0,220),
            time: parseTime(item.date),
            location: String(item.location || ""),
            summary: String(item.summary || "").slice(0,900),
            url: safeUrl(item.url),
            tags: item.tags || ["humanitarian"],
            source: "ReliefWeb",
          };
        }
      }
    ];

    // Helper functions
    function parseTime(x){
      if(!x) return null;
      const d = new Date(String(x).trim());
      if(!isNaN(d.getTime())) return d.getTime();
      return null;
    }
    function stripHtml(html){
      const div = document.createElement("div");
      div.innerHTML = String(html||"");
      return (div.textContent || "").trim();
    }
    function safeUrl(u){
      const s = String(u||"").trim();
      if(!s) return "";
      try{
        const url = new URL(s, location.href);
        return (url.protocol==="http:" || url.protocol==="https:") ? url.href : "";
      }catch{ return ""; }
    }

    // ==== Clustering Logic ====
    function tokenize(s){
      return (s||"").toLowerCase().replace(/[^a-z0-9\s]/g," ").split(/\s+/).filter(w => w.length >= 4).slice(0, 80);
    }
    function jaccard(a,b){
      const A = new Set(a), B = new Set(b);
      let inter=0;
      for(const x of A) if(B.has(x)) inter++;
      const union = A.size + B.size - inter;
      return union ? inter/union : 0;
    }
    function clusterEvents(events){
      const clusters = [];
      for(const ev of events){
        const tokens = tokenize(ev.title + " " + ev.location + " " + ev.summary);
        const t = ev.time || 0;
        let best = null, bestScore = 0;

        for(const c of clusters){
          const dt = Math.abs((c.time || t) - t);
          const timeScore = (ev.time && c.time) ? Math.max(0, 1 - dt/(1000*3600*24*7)) : 0.55;
          const sim = jaccard(tokens, c.tokens);
          const locSim = jaccard(tokenize(ev.location), tokenize(c.locationHint));
          const score = 0.55*sim + 0.25*timeScore + 0.20*locSim;
          if(score > bestScore){ bestScore=score; best=c; }
        }

        if(best && bestScore >= 0.26){
          best.items.push(ev);
          best.tokens = new Set([...best.tokens, ...tokens]);
          best.locationHint = best.locationHint || ev.location || "";
          best.time = best.time || ev.time || null;
          best.tags = new Set([...best.tags, ...(ev.tags||[])]);
        } else {
          clusters.push({
            id: "c_" + Safe.hash((ev.title||"") + "|" + (ev.location||"") + "|" + String(ev.time||"")),
            time: ev.time || null,
            locationHint: ev.location || "",
            tokens: new Set(tokens),
            tags: new Set(ev.tags || []),
            items: [ev]
          });
        }
      }

      return clusters.map(c => {
        const sources = [...new Set(c.items.map(i=>i.source))];
        const corroboration = Safe.clamp((sources.length - 1) / 3, 0, 1);
        const metaQuality = Safe.clamp(
          (avg(c.items.map(i=> i.url ? 1 : 0))*0.35) +
          (avg(c.items.map(i=> i.location ? 1 : 0))*0.35) +
          (avg(c.items.map(i=> i.time ? 1 : 0))*0.30),
          0,1
        );
        const sims = [];
        for(let i=0;i<c.items.length;i++){
          for(let j=i+1;j<c.items.length;j++){
            sims.push(jaccard(tokenize(c.items[i].title+" "+c.items[i].summary), tokenize(c.items[j].title+" "+c.items[j].summary)));
          }
        }
        const cohesion = sims.length ? avg(sims) : 0.55;
        const divergence = Safe.clamp(1 - cohesion, 0, 1);
        const confidence = Safe.clamp(0.55*corroboration + 0.35*metaQuality + 0.10*(1-divergence), 0, 1);

        return {
          id: c.id,
          time: c.time,
          location: c.locationHint,
          tags: [...c.tags],
          items: c.items,
          sources,
          corroboration,
          divergence,
          confidence,
          text: c.items.map(i=>i.title+" "+i.summary).join(" ")
        };
      }).sort((a,b) => (b.confidence - a.confidence) || ((b.time||0)-(a.time||0)));
    }
    function avg(xs){
      if(!xs.length) return 0;
      return xs.reduce((a,b)=>a+b,0)/xs.length;
    }

    // ==== Research Modules ====

    // Module 1: Ontology Analysis
    function analyzeOntology(clusters){
      const frameworks = {
        humanitarian: /\b(ihl|geneva|civilian|protected|proportionalit|humanitarian law|war crime|massacre)\b/i,
        military: /\b(neutrali|target|combatant|collateral|roe|rules of engagement|operation|strike|raid)\b/i,
        political: /\b(aggress|provoc|retaliat|legitima|sovereignty|intervention|regime|sanction)\b/i
      };

      return clusters.map(c => {
        const text = c.text.toLowerCase();
        const profile = {};
        let total = 0;
        for(const [name, regex] of Object.entries(frameworks)){
          const matches = (text.match(regex) || []).length;
          profile[name] = matches;
          total += matches;
        }
        if(total > 0){
          for(const k of Object.keys(profile)) profile[k] /= total;
        }
        const diversity = Object.values(profile).filter(v => v > 0.15).length;
        return { ...c, ontology: profile, ontoDiversity: diversity };
      });
    }

    // Module 2: Temporal Tracking
    const TemporalTracker = {
      history: [], // {time, clusters}
      add(clusters){
        this.history.push({time: Date.now(), clusters: clusters.map(c=>({id:c.id, divergence:c.divergence}))});
        if(this.history.length > 50) this.history.shift(); // keep last 50 snapshots
      },
      analyze(){
        if(this.history.length < 2) return [];
        const alerts = [];
        const recent = this.history.slice(-10);
        for(let i=1; i<recent.length; i++){
          const prev = recent[i-1], curr = recent[i];
          const dt = (curr.time - prev.time) / 1000 / 60; // minutes
          for(const c of curr.clusters){
            const p = prev.clusters.find(x => x.id === c.id);
            if(p){
              const velocity = (p.divergence - c.divergence) / dt; // negative = converging
              if(velocity < -0.02){ // rapid convergence
                alerts.push({id: c.id, type: "rapid_convergence", velocity, time: curr.time});
              }
            }
          }
        }
        return alerts;
      }
    };

    // Module 3: Provenance Mapping
    function mapProvenance(clusters){
      const nodes = new Set();
      const edges = [];
      for(const c of clusters){
        for(const item of c.items){
          nodes.add(item.source);
        }
        // Check for dependencies
        for(let i=0; i<c.items.length; i++){
          for(let j=i+1; j<c.items.length; j++){
            const a = c.items[i], b = c.items[j];
            let weight = 0;
            if(a.url && b.url && a.url === b.url) weight += 1.0; // same URL
            const timeDiff = Math.abs((a.time||0) - (b.time||0)) / 1000 / 60;
            if(timeDiff < 60) weight += 0.4; // within an hour
            const textSim = jaccard(tokenize(a.title+" "+a.summary), tokenize(b.title+" "+b.summary));
            if(textSim > 0.8) weight += 0.6; // very similar text
            if(weight > 0.3){
              edges.push({from: a.source, to: b.source, weight});
            }
          }
        }
      }

      // Calculate independence scores
      const scores = {};
      for(const node of nodes){
        const deps = edges.filter(e => e.from === node || e.to === node);
        const totalWeight = deps.reduce((s,e)=>s+e.weight, 0);
        const possibleEdges = nodes.size - 1;
        scores[node] = possibleEdges > 0 ? Safe.clamp(1 - totalWeight / possibleEdges, 0, 1) : 1;
      }

      return { nodes: [...nodes], edges, scores };
    }

    // Module 4: Action Thresholds
    const ActionMatrix = {
      actions: [
        {name: "Support general humanitarian relief", risk: 0.1, threshold: 0.35},
        {name: "Share careful multi-source summary", risk: 0.2, threshold: 0.50},
        {name: "Join organized advocacy campaign", risk: 0.4, threshold: 0.65},
        {name: "Contact representatives for policy", risk: 0.7, threshold: 0.80},
        {name: "Amplify claims about named individuals", risk: 0.9, threshold: 0.90},
      ],
      getAvailable(confidence){
        return this.actions.filter(a => confidence >= a.threshold);
      },
      generatePlan(cluster){
        const available = this.getAvailable(cluster.confidence);
        if(!available.length) return "Confidence too low for any recommended actions.";
        const plan = [
          `Cluster: ${cluster.location} (${cluster.sources.length} sources, confidence ${(cluster.confidence*100).toFixed(0)}%)`,
          "",
          "Available actions based on confidence:",
          ...available.map(a => `‚Ä¢ ${a.name} (risk level: ${(a.risk*100).toFixed(0)}%)`)
        ];
        return plan.join("\n");
      }
    };

    // Module 5: Adversarial Simulation
    function runRedTeam(scenario, realClusters){
      const scenarios = {
        coordinated: () => {
          const fake = [
            {title:"Testistan: clashes reported", date:"2026-01-01", location:"Testistan", summary:"Multiple sources report fighting near capital", url:"", tags:["war"], source:"FakeSource1"},
            {title:"Conflict in Testistan escalates", date:"2026-01-01", location:"Testistan", summary:"Fighting intensifies in Testistan region", url:"", tags:["war"], source:"FakeSource2"},
            {title:"Testistan violence continues", date:"2026-01-01", location:"Testistan", summary:"Ongoing clashes in Testistan capital area", url:"", tags:["war"], source:"FakeSource3"},
          ];
          return fake.map(CONNECTORS[0].normalize);
        },
        // ... other scenarios
      };
      const synth = scenarios[scenario] ? scenarios[scenario]() : [];
      const combined = [...realClusters.flatMap(c=>c.items), ...synth];
      const testClusters = clusterEvents(combined);
      const synthCluster = testClusters.find(c => c.items.some(i => i.source.startsWith("FakeSource")));
      return {
        detected: synthCluster && synthCluster.divergence < 0.4 && synthCluster.confidence > 0.65,
        cluster: synthCluster,
        message: synthCluster ? 
          (synthCluster.divergence < 0.4 && synthCluster.confidence > 0.65 ?
            "‚ùå FAILED: Synthetic attack was not flagged. System gave high confidence to coordinated fabrication." :
            "‚úÖ PASSED: Synthetic attack was flagged as suspicious due to divergence/confidence patterns.") :
          "Synthetic items did not cluster together."
      };
    }

    // Module 6: Performance Testing
    async function runPerformanceTest(){
      const sizes = [100, 250, 500, 1000];
      const results = [];
      for(const n of sizes){
        const fake = Array(n).fill(0).map((_,i) => ({
          title: `Event ${i}`,
          date: new Date(Date.now() - Math.random()*7*24*3600*1000).toISOString(),
          location: ["Region A","Region B","Region C"][i%3],
          summary: `Description of event ${i} with some details`,
          url: `https://example.com/${i}`,
          tags: ["test"],
          source: "TestSource"
        }));
        const normed = fake.map(CONNECTORS[0].normalize);
        const t0 = performance.now();
        const clusters = clusterEvents(normed);
        const t1 = performance.now();
        results.push({n, time: t1-t0, clusters: clusters.length});
      }
      return results;
    }

    // ==== State Management ====
    const State = {
      settings: {
        offlineCache: true,
        autoRefresh: true,
        localAnalytics: false,
      },
      sourceConfig: {},
      lastFetchAt: null,
      lastClusters: [],
      analytics: { refreshes:0, modulesRun:0, lastDay: null, streak:0 },
    };

    async function loadState(){
      const s = await DB.get("settings","app")?.catch(()=>null);
      if(s?.value) Object.assign(State.settings, s.value);
      const sc = await DB.get("sources","config")?.catch(()=>null);
      if(sc?.value) State.sourceConfig = sc.value;
      const cache = await DB.get("cache","last")?.catch(()=>null);
      if(cache?.value){
        State.lastFetchAt = cache.value.lastFetchAt || null;
        State.lastClusters = cache.value.clusters || [];
      }
      const an = await DB.get("analytics","stats")?.catch(()=>null);
      if(an?.value) State.analytics = an.value;
    }

    async function persistSettings(){
      await DB.put("settings", {id:"app", value: State.settings});
    }
    async function persistCache(){
      await DB.put("cache", {id:"last", value: { lastFetchAt: State.lastFetchAt, clusters: State.lastClusters }});
    }
    async function persistAnalytics(){
      await DB.put("analytics", {id:"stats", value: State.analytics});
    }

    // ==== DOM Helpers ====
    const $ = (id)=>document.getElementById(id);
    function toast(msg){
      const d=document.createElement("div");
      d.textContent=msg;
      d.style.cssText="position:fixed;left:50%;bottom:20px;transform:translateX(-50%);background:rgba(0,0,0,.8);color:#fff;padding:8px 12px;border-radius:12px;z-index:200;font-size:13px";
      document.body.appendChild(d);
      setTimeout(()=>d.remove(),2400);
    }

    // ==== UI Rendering ====
    function renderFeed(){
      const clusters = State.lastClusters;
      if(!clusters.length){
        $("eventList").innerHTML = '<div class="tiny muted">No data yet. Click "Refresh Sources".</div>';
        return;
      }
      $("eventList").innerHTML = clusters.slice(0,50).map(c => {
        const t = c.time ? new Date(c.time).toLocaleString() : "‚Äî";
        const divTag = c.divergence >= 0.6 ? '<span class="tag bad">High divergence</span>' :
                       c.divergence >= 0.35 ? '<span class="tag warn">Medium divergence</span>' :
                       '<span class="tag good">Low divergence</span>';
        const conf = (c.confidence*100).toFixed(0)+"%";
        return `
          <div class="ev">
            <div class="top">
              <div>
                <div class="ttl">${Safe.escape(c.items[0]?.title || "Untitled")}</div>
                <div class="meta">${Safe.escape(c.location||"")} ‚Ä¢ ${t}</div>
              </div>
              <div class="score"><b>${conf}</b></div>
            </div>
            <div class="desc">${Safe.escape(c.items[0]?.summary || "")}</div>
            <div class="links">
              ${divTag}
              <span class="tag">Sources: ${c.sources.length}</span>
            </div>
          </div>
        `;
      }).join("");
    }

    function renderSources(){
      const cards = CONNECTORS.map(c => {
        const cfg = State.sourceConfig[c.id] || { enabled: c.enabledByDefault };
        return `
          <div class="card" style="box-shadow:none">
            <div class="hd">
              <div>
                <h4>${Safe.escape(c.name)}</h4>
                <div class="tiny muted">${Safe.escape(c.hint)}</div>
              </div>
              <span class="pill">${Safe.escape(c.kind)}</span>
            </div>
            <div class="bd">
              <label style="display:flex; align-items:center; gap:8px">
                <input type="checkbox" data-cid="${c.id}" ${cfg.enabled?"checked":""}>
                <span class="tiny">Enabled</span>
              </label>
            </div>
          </div>
        `;
      }).join("");
      $("sourceCards").innerHTML = cards;
      $("sourceCards").querySelectorAll("input[data-cid]").forEach(inp => {
        inp.addEventListener("change", async ()=>{
          const cid = inp.getAttribute("data-cid");
          if(!State.sourceConfig[cid]) State.sourceConfig[cid] = {};
          State.sourceConfig[cid].enabled = inp.checked;
          await DB.put("sources", {id:"config", value: State.sourceConfig});
        });
      });
    }

    function renderSettings(){
      $("offlineCacheToggle").checked = !!State.settings.offlineCache;
      $("autoRefreshToggle").checked = !!State.settings.autoRefresh;
      $("localAnalyticsToggle").checked = !!State.settings.localAnalytics;
    }

    function renderHud(){
      $("hudClusters").textContent = State.lastClusters.length;
      $("hudRefreshes").textContent = State.analytics.refreshes || 0;
      $("hudModules").textContent = `${State.analytics.modulesRun || 0}/7`;
      $("hudStreak").textContent = State.analytics.streak || 0;
      const momentum = Safe.clamp((State.lastClusters.length || 0)*2, 0, 100);
      $("momentumBar").style.setProperty("--w", momentum+"%");
    }

    function updateHeaderPills(){
      $("freshPill").textContent = State.lastFetchAt ? new Date(State.lastFetchAt).toLocaleTimeString() : "‚Äî";
      $("divPill").textContent = State.lastClusters.length ? (avg(State.lastClusters.map(c=>c.divergence))*100).toFixed(0)+"%" : "‚Äî";
      $("cachePill").textContent = State.settings.offlineCache ? "On" : "Off";
      
      // Ontology pill
      if(State.lastClusters.length && State.lastClusters[0].ontoDiversity !== undefined){
        $("ontoPill").textContent = avg(State.lastClusters.map(c=>c.ontoDiversity||0)).toFixed(1);
      }
      
      // Provenance pill
      const provData = JSON.parse(sessionStorage.getItem("provenance") || "null");
      if(provData?.scores){
        const indep = avg(Object.values(provData.scores));
        $("provPill").textContent = (indep*100).toFixed(0)+"%";
      }
    }

    // ==== Core Operations ====
    async function refreshSources(){
      if(!Safe.limiter.allow()){
        toast("Rate limit - please wait before refreshing again");
        return;
      }

      const params = {
        windowDays: +$("window").value,
        region: $("region").value,
      };

      const allEvents = [];
      let ok=0, fail=0;

      for(const c of CONNECTORS){
        const cfg = State.sourceConfig[c.id] || {enabled: c.enabledByDefault};
        if(!cfg.enabled) continue;
        try{
          const items = await c.fetch(params);
          const normed = items.map(it=>c.normalize(it)).filter(x=>x.title || x.summary);
          allEvents.push(...normed);
          ok++;
        }catch(e){
          console.warn("Source failed:", c.id, e);
          fail++;
        }
      }

      const clusters = clusterEvents(allEvents);
      State.lastFetchAt = Date.now();
      State.lastClusters = clusters;
      State.analytics.refreshes++;

      if(State.settings.offlineCache) await persistCache();
      if(State.settings.localAnalytics) await persistAnalytics();

      $("srcOk").textContent = ok;
      $("srcPartial").textContent = 0;
      $("srcFail").textContent = fail;
      $("clusterCount").textContent = clusters.length;

      TemporalTracker.add(clusters);

      renderFeed();
      updateHeaderPills();
      renderHud();
      drawHealthViz();
      updatePlanClusterOptions();
      toast(`Refreshed: ${ok} sources OK, ${fail} failed`);
    }

    async function useCache(){
      if(State.lastClusters?.length){
        renderFeed();
        updateHeaderPills();
        renderHud();
        drawHealthViz();
        toast("Loaded cached data");
      } else {
        toast("No cached data available");
      }
    }

    function exportJSON(){
      const data = {
        generated: new Date().toISOString(),
        clusters: State.lastClusters.map(c => ({
          id: c.id,
          confidence: c.confidence,
          divergence: c.divergence,
          location: c.location,
          time: c.time,
          sources: c.sources,
          items: c.items.map(i => ({
            title: i.title,
            summary: i.summary,
            url: i.url,
            source: i.source
          }))
        }))
      };
      const blob = new Blob([JSON.stringify(data,null,2)],{type:"application/json"});
      const a = document.createElement("a");
      a.href=URL.createObjectURL(blob);
      a.download="conflict_analysis_export.json";
      a.click();
      toast("Export downloaded");
    }

    // ==== Research Module Functions ====
    async function runOntologyAnalysis(){
      if(!State.lastClusters.length){
        toast("No data to analyze. Refresh first.");
        return;
      }
      const analyzed = analyzeOntology(State.lastClusters);
      State.lastClusters = analyzed;
      
      // Store results
      await DB.put("ontology", {id:"last", value: analyzed});
      
      // Render results
      const results = analyzed.map(c => {
        const profile = Object.entries(c.ontology || {})
          .map(([k,v]) => `${k}: ${(v*100).toFixed(0)}%`)
          .join(", ");
        return `
          <div style="margin-bottom:12px; padding:10px; background:rgba(0,0,0,.2); border-radius:12px">
            <div class="tiny"><b>${Safe.escape(c.location || "Unknown")}</b></div>
            <div class="tiny muted" style="margin-top:4px">${profile || "No clear framework detected"}</div>
            <div class="tiny muted">Framework diversity: ${c.ontoDiversity || 0} (${c.ontoDiversity >= 2 ? "collision likely" : "consistent"})</div>
          </div>
        `;
      }).slice(0,10).join("");
      
      $("ontoResultsBox").innerHTML = results || '<div class="muted">No ontology patterns detected</div>';
      
      drawOntologyMatrix(analyzed);
      updateHeaderPills();
      State.analytics.modulesRun++;
      persistAnalytics();
      toast("Ontology analysis complete");
    }

    function runTemporalTracking(){
      const alerts = TemporalTracker.analyze();
      if(!alerts.length){
        $("tempAlertsBox").innerHTML = '<div class="muted">No rapid convergence detected. This is normal.</div>';
      } else {
        $("tempAlertsBox").innerHTML = alerts.map(a => `
          <div class="tag warn" style="display:block; margin-bottom:8px">
            <b>Alert:</b> Cluster ${a.id} - rapid convergence (velocity: ${a.velocity.toFixed(3)}/min)
            <div class="tiny" style="margin-top:4px">This could be natural consensus building or coordinated messaging</div>
          </div>
        `).join("");
      }
      drawTemporalViz();
      State.analytics.modulesRun++;
      persistAnalytics();
      toast("Temporal tracking updated");
    }

    function runProvenanceMapping(){
      if(!State.lastClusters.length){
        toast("No data to analyze");
        return;
      }
      const prov = mapProvenance(State.lastClusters);
      sessionStorage.setItem("provenance", JSON.stringify(prov));
      
      // Render scores
      const scores = Object.entries(prov.scores)
        .sort((a,b) => b[1]-a[1])
        .map(([source, score]) => `
          <div style="margin-bottom:8px">
            <div class="tiny"><b>${Safe.escape(source)}</b></div>
            <div class="meter" style="height:6px; margin-top:4px">
              <i style="--w: ${(score*100).toFixed(0)}%; background:${score>0.7?'var(--good)':score>0.4?'var(--warn)':'var(--bad)'}"></i>
            </div>
            <div class="tiny muted">Independence: ${(score*100).toFixed(0)}%</div>
          </div>
        `).join("");
      
      $("provScoresBox").innerHTML = scores;
      drawProvenanceGraph(prov);
      updateHeaderPills();
      State.analytics.modulesRun++;
      persistAnalytics();
      toast("Provenance mapping complete");
    }

    function calculateActionThresholds(){
      if(!State.lastClusters.length){
        toast("No clusters available");
        return;
      }
      drawActionMatrix();
      updatePlanClusterOptions();
      State.analytics.modulesRun++;
      persistAnalytics();
      toast("Action thresholds calculated");
    }

    function updatePlanClusterOptions(){
      const opts = State.lastClusters.slice(0,20).map(c => 
        `<option value="${c.id}">${Safe.escape((c.location||"") + " - " + (c.items[0]?.title||"").slice(0,50))}</option>`
      ).join("");
      $("planCluster").innerHTML = opts || '<option>No clusters</option>';
    }

    function generateActionPlan(){
      const cid = $("planCluster").value;
      const cluster = State.lastClusters.find(c => c.id === cid);
      if(!cluster){
        $("actPlansBox").innerHTML = '<div class="muted">Select a cluster</div>';
        return;
      }
      const plan = ActionMatrix.generatePlan(cluster);
      $("actPlansBox").innerHTML = '<pre style="white-space:pre-wrap">' + Safe.escape(plan) + '</pre>';
    }

    async function runAdversarialTest(){
      const scenario = document.querySelector('input[name="advScenario"]:checked')?.value || "coordinated";
      if(!State.lastClusters.length){
        toast("Need real data first. Refresh sources.");
        return;
      }
      
      const result = runRedTeam(scenario, State.lastClusters);
      
      const html = `
        <div class="card" style="box-shadow:none; background:${result.detected?'rgba(125,255,178,.08)':'rgba(255,125,155,.08)'}">
          <div class="hd">
            <h4>Simulation Result: ${scenario}</h4>
          </div>
          <div class="bd">
            <div style="font-size:18px; margin-bottom:12px">${result.message}</div>
            ${result.cluster ? `
              <div class="tiny muted">
                Synthetic cluster confidence: ${(result.cluster.confidence*100).toFixed(0)}%<br>
                Synthetic cluster divergence: ${(result.cluster.divergence*100).toFixed(0)}%<br>
                Sources in cluster: ${result.cluster.sources.length}
              </div>
            ` : ''}
            <div class="sep"></div>
            <div class="tiny muted">
              <b>Interpretation:</b> ${result.detected ? 
                "Your system's divergence + confidence scoring successfully flagged the coordinated attack as suspicious." :
                "The coordinated attack achieved high confidence, suggesting your system could be vulnerable to this attack pattern. Consider: (1) stronger provenance checking, (2) velocity anomaly detection, (3) cross-framework consistency analysis."
              }
            </div>
          </div>
        </div>
      `;
      
      $("advResultsBox").innerHTML = html;
      State.analytics.modulesRun++;
      persistAnalytics();
      toast("Red team simulation complete");
    }

    // Participatory functions
    async function submitCommunityKnowledge(){
      if(!$("partConsent").checked){
        toast("Please acknowledge the consent checkbox");
        return;
      }
      
      const data = {
        id: "part_" + Date.now(),
        type: $("partType").value,
        location: $("partLocation").value,
        time: $("partTime").value,
        content: $("partContent").value,
        anonymous: $("partAnon").checked,
        submitted: Date.now()
      };
      
      await DB.put("participatory", data);
      
      $("partContent").value = "";
      $("partLocation").value = "";
      $("partTime").value = "";
      
      toast("Submission stored locally (encrypted)");
      renderParticipatory();
    }

    async function renderParticipatory(){
      const subs = await DB.all("participatory");
      if(!subs.length){
        $("partReviewBox").innerHTML = '<div class="muted">No submissions yet</div>';
        return;
      }
      
      $("partReviewBox").innerHTML = subs.map(s => `
        <div style="margin-bottom:12px; padding:10px; background:rgba(0,0,0,.2); border-radius:12px">
          <div class="tiny"><b>${Safe.escape(s.type)}</b> ${s.anonymous ? '(anonymous)' : ''}</div>
          <div class="tiny muted" style="margin-top:4px">
            ${s.location ? Safe.escape(s.location) + " ‚Ä¢ " : ""}
            ${s.time ? Safe.escape(s.time) + " ‚Ä¢ " : ""}
            ${new Date(s.submitted).toLocaleDateString()}
          </div>
          <div class="tiny" style="margin-top:8px">${Safe.escape(s.content.slice(0,200))}${s.content.length>200?"...":""}</div>
        </div>
      `).join("");
    }

    async function clearAllParticipatory(){
      const subs = await DB.all("participatory");
      for(const s of subs) await DB.del("participatory", s.id);
      renderParticipatory();
      toast("All submissions cleared");
    }

    // Performance testing
    async function runPerformanceTests(){
      toast("Running load tests (may take 10-20s)...");
      const results = await runPerformanceTest();
      
      const html = results.map(r => `
        <div style="margin-bottom:8px">
          <div class="tiny"><b>${r.n} events</b> ‚Üí ${r.time.toFixed(1)}ms (${r.clusters} clusters)</div>
          <div class="meter" style="height:6px; margin-top:4px">
            <i style="--w: ${Math.min(100, r.time/20).toFixed(0)}%; background:${r.time<1000?'var(--good)':r.time<2000?'var(--warn)':'var(--bad)'}"></i>
          </div>
        </div>
      `).join("");
      
      $("perfMetricsBox").innerHTML = html;
      drawPerfScaling(results);
      State.analytics.modulesRun++;
      persistAnalytics();
      toast("Performance tests complete");
    }

    // ==== Canvas Visualizations ====
    function drawHealthViz(){
      const canvas = $("healthViz");
      const ctx = canvas.getContext("2d");
      const w = canvas.width, h = canvas.height;
      ctx.clearRect(0,0,w,h);
      
      // Simple pulse visualization
      const nodes = [
        {x:0.25, y:0.5, r:8, label:"Fetch", color:"rgba(124,247,197,.9)"},
        {x:0.5, y:0.3, r:8, label:"Cluster", color:"rgba(134,183,255,.9)"},
        {x:0.75, y:0.5, r:8, label:"Analyze", color:"rgba(212,165,255,.9)"},
        {x:0.5, y:0.7, r:8, label:"Store", color:"rgba(255,210,125,.9)"},
      ];
      
      ctx.strokeStyle = "rgba(124,247,197,.3)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      nodes.forEach((n,i) => {
        const next = nodes[(i+1)%nodes.length];
        ctx.moveTo(n.x*w, n.y*h);
        ctx.lineTo(next.x*w, next.y*h);
      });
      ctx.stroke();
      
      nodes.forEach(n => {
        ctx.fillStyle = n.color;
        ctx.beginPath();
        ctx.arc(n.x*w, n.y*h, n.r, 0, Math.PI*2);
        ctx.fill();
        
        ctx.fillStyle = "rgba(255,255,255,.9)";
        ctx.font = "11px ui-sans-serif";
        ctx.textAlign = "center";
        ctx.fillText(n.label, n.x*w, n.y*h - 14);
      });
    }

    function drawOntologyMatrix(clusters){
      const canvas = $("ontoCanvas");
      const ctx = canvas.getContext("2d");
      const w = canvas.width, h = canvas.height;
      ctx.clearRect(0,0,w,h);
      
      const frameworks = ["humanitarian", "military", "political"];
      const cellW = 60, cellH = 30;
      const startX = 120, startY = 40;
      
      // Headers
      ctx.fillStyle = "rgba(255,255,255,.7)";
      ctx.font = "11px ui-sans-serif";
      frameworks.forEach((f,i) => {
        ctx.fillText(f, startX + i*cellW + cellW/2, startY - 10);
      });
      
      // Rows
      clusters.slice(0,10).forEach((c,row) => {
        ctx.fillText(c.location.slice(0,15), 10, startY + row*cellH + cellH/2 + 4);
        
        frameworks.forEach((f,col) => {
          const val = c.ontology?.[f] || 0;
          const intensity = val * 255;
          ctx.fillStyle = `rgba(124,247,197,${val})`;
          ctx.fillRect(startX + col*cellW, startY + row*cellH, cellW-2, cellH-2);
        });
      });
    }

    function drawTemporalViz(){
      const canvas = $("tempCanvas");
      const ctx = canvas.getContext("2d");
      const w = canvas.width, h = canvas.height;
      ctx.clearRect(0,0,w,h);
      
      if(TemporalTracker.history.length < 2){
        ctx.fillStyle = "rgba(255,255,255,.5)";
        ctx.font = "13px ui-sans-serif";
        ctx.fillText("Not enough temporal data yet. Refresh a few times over time.", 20, h/2);
        return;
      }
      
      const history = TemporalTracker.history.slice(-10);
      const topClusters = State.lastClusters.slice(0,5);
      
      const marginL = 50, marginR = 20, marginT = 20, marginB = 30;
      const plotW = w - marginL - marginR;
      const plotH = h - marginT - marginB;
      
      // Axes
      ctx.strokeStyle = "rgba(255,255,255,.2)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(marginL, marginT);
      ctx.lineTo(marginL, h-marginB);
      ctx.lineTo(w-marginR, h-marginB);
      ctx.stroke();
      
      // Labels
      ctx.fillStyle = "rgba(255,255,255,.6)";
      ctx.font = "10px ui-sans-serif";
      ctx.fillText("Time ‚Üí", w-marginR-40, h-marginB+20);
      ctx.save();
      ctx.translate(15, h/2);
      ctx.rotate(-Math.PI/2);
      ctx.fillText("Divergence", 0, 0);
      ctx.restore();
      
      // Plot lines for top clusters
      const colors = ["rgba(124,247,197,.8)", "rgba(134,183,255,.8)", "rgba(212,165,255,.8)", "rgba(255,210,125,.8)", "rgba(255,171,112,.8)"];
      topClusters.forEach((cluster, cidx) => {
        const points = [];
        history.forEach((snap, idx) => {
          const c = snap.clusters.find(x => x.id === cluster.id);
          if(c){
            const x = marginL + (idx / (history.length-1)) * plotW;
            const y = marginT + (1 - c.divergence) * plotH;
            points.push({x,y});
          }
        });
        
        if(points.length > 1){
          ctx.strokeStyle = colors[cidx % colors.length];
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(points[0].x, points[0].y);
          for(let i=1; i<points.length; i++){
            ctx.lineTo(points[i].x, points[i].y);
          }
          ctx.stroke();
        }
      });
    }

    function drawProvenanceGraph(prov){
      const canvas = $("provCanvas");
      const ctx = canvas.getContext("2d");
      const w = canvas.width, h = canvas.height;
      ctx.clearRect(0,0,w,h);
      
      // Simple force-directed layout (fake it with random positions)
      const positions = {};
      [...prov.nodes].forEach((node, i) => {
        const angle = (i / prov.nodes.length) * Math.PI * 2;
        const radius = Math.min(w,h) * 0.35;
        positions[node] = {
          x: w/2 + Math.cos(angle) * radius,
          y: h/2 + Math.sin(angle) * radius
        };
      });
      
      // Draw edges
      prov.edges.forEach(e => {
        const from = positions[e.from];
        const to = positions[e.to];
        if(from && to){
          ctx.strokeStyle = `rgba(255,125,155,${e.weight})`;
          ctx.lineWidth = 1 + e.weight * 3;
          ctx.beginPath();
          ctx.moveTo(from.x, from.y);
          ctx.lineTo(to.x, to.y);
          ctx.stroke();
        }
      });
      
      // Draw nodes
      prov.nodes.forEach(node => {
        const pos = positions[node];
        const score = prov.scores[node] || 0.5;
        ctx.fillStyle = score > 0.7 ? "rgba(125,255,178,.9)" : score > 0.4 ? "rgba(255,210,125,.9)" : "rgba(255,125,155,.9)";
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, 8, 0, Math.PI*2);
        ctx.fill();
        
        ctx.fillStyle = "rgba(255,255,255,.9)";
        ctx.font = "10px ui-sans-serif";
        ctx.textAlign = "center";
        ctx.fillText(node.slice(0,10), pos.x, pos.y - 12);
      });
    }

    function drawActionMatrix(){
      const canvas = $("actCanvas");
      const ctx = canvas.getContext("2d");
      const w = canvas.width, h = canvas.height;
      ctx.clearRect(0,0,w,h);
      
      const actions = ActionMatrix.actions;
      const confLevels = [0, 0.25, 0.5, 0.75, 1.0];
      
      const cellW = 80, cellH = 40;
      const startX = 220, startY = 40;
      
      // Column headers (confidence levels)
      ctx.fillStyle = "rgba(255,255,255,.7)";
      ctx.font = "10px ui-sans-serif";
      confLevels.forEach((c,i) => {
        ctx.fillText(`${(c*100).toFixed(0)}%`, startX + i*cellW + cellW/2, startY - 10);
      });
      
      // Row headers + cells
      actions.forEach((action, row) => {
        ctx.fillText(action.name.slice(0,25), 10, startY + row*cellH + cellH/2 + 4);
        
        confLevels.forEach((conf, col) => {
          const appropriate = conf >= action.threshold;
          ctx.fillStyle = appropriate ? "rgba(125,255,178,.6)" : "rgba(255,125,155,.3)";
          ctx.fillRect(startX + col*cellW, startY + row*cellH, cellW-2, cellH-2);
        });
      });
    }

    function drawPerfScaling(results){
      const canvas = $("perfCanvas");
      const ctx = canvas.getContext("2d");
      const w = canvas.width, h = canvas.height;
      ctx.clearRect(0,0,w,h);
      
      const marginL = 60, marginR = 20, marginT = 20, marginB = 40;
      const plotW = w - marginL - marginR;
      const plotH = h - marginT - marginB;
      
      // Axes
      ctx.strokeStyle = "rgba(255,255,255,.2)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(marginL, marginT);
      ctx.lineTo(marginL, h-marginB);
      ctx.lineTo(w-marginR, h-marginB);
      ctx.stroke();
      
      ctx.fillStyle = "rgba(255,255,255,.6)";
      ctx.font = "10px ui-sans-serif";
      ctx.fillText("Dataset Size", w/2, h-marginB+25);
      ctx.save();
      ctx.translate(20, h/2);
      ctx.rotate(-Math.PI/2);
      ctx.fillText("Time (ms)", 0, 0);
      ctx.restore();
      
      // Plot points
      const maxN = Math.max(...results.map(r=>r.n));
      const maxT = Math.max(...results.map(r=>r.time));
      
      ctx.fillStyle = "rgba(124,247,197,.8)";
      results.forEach(r => {
        const x = marginL + (r.n / maxN) * plotW;
        const y = h - marginB - (r.time / maxT) * plotH;
        ctx.beginPath();
        ctx.arc(x, y, 4, 0, Math.PI*2);
        ctx.fill();
      });
      
      // Threshold line (2000ms)
      if(maxT > 2000){
        const y = h - marginB - (2000 / maxT) * plotH;
        ctx.strokeStyle = "rgba(255,125,155,.5)";
        ctx.setLineDash([5,5]);
        ctx.beginPath();
        ctx.moveTo(marginL, y);
        ctx.lineTo(w-marginR, y);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle = "rgba(255,125,155,.8)";
        ctx.fillText("UX threshold (2s)", w-marginR-80, y-5);
      }
    }

    // ==== Tab System ====
    function initTabs(){
      document.querySelectorAll(".tabs button").forEach(btn => {
        btn.addEventListener("click", () => {
          const parent = btn.closest(".bd") || btn.closest(".card");
          const tabName = btn.getAttribute("data-tab");
          
          parent.querySelectorAll(".tabs button").forEach(b => b.classList.remove("active"));
          btn.classList.add("active");
          
          parent.querySelectorAll(".tabContent").forEach(tc => tc.classList.remove("active"));
          const target = parent.querySelector("#" + tabName);
          if(target) target.classList.add("active");
        });
      });
    }

    // ==== HUD ====
    function makeHudDraggable(hud){
      let x=0,y=0,drag=false;
      hud.addEventListener("pointerdown",e=>{
        if(e.target.tagName === "BUTTON") return;
        drag=true;x=e.clientX;y=e.clientY;hud.setPointerCapture(e.pointerId);
      });
      hud.addEventListener("pointermove",e=>{
        if(!drag) return;
        const dx=e.clientX-x, dy=e.clientY-y;
        const r=hud.getBoundingClientRect();
        hud.style.right="auto";
        hud.style.bottom="auto";
        hud.style.left=(r.left+dx)+"px";
        hud.style.top=(r.top+dy)+"px";
        x=e.clientX;y=e.clientY;
      });
      hud.addEventListener("pointerup",()=>drag=false);
    }

    // ==== Initialization ====
    (async function boot(){
      await DB.open();
      await loadState();
      if("serviceWorker" in navigator) await registerSW();
      
      renderSources();
      renderSettings();
      renderFeed();
      renderHud();
      updateHeaderPills();
      drawHealthViz();
      renderParticipatory();
      initTabs();
      makeHudDraggable($("hud"));
      
      // Splash
      const seen = await DB.get("settings", "splashSeen");
      if(seen?.value){
        $("splash").classList.add("hide");
        setTimeout(()=>$("splash").style.display="none", 600);
      }
      
      // Parallax
      window.addEventListener("pointermove", (e)=>{
        const x = (e.clientX / window.innerWidth - 0.5) * 20;
        const y = (e.clientY / window.innerHeight - 0.5) * 16;
        $("parallaxBg").style.setProperty("--px", x+"px");
        $("parallaxBg").style.setProperty("--py", y+"px");
      }, {passive:true});
      
      // Bindings
      $("enterBtn").addEventListener("click", async ()=>{
        await DB.put("settings", {id:"splashSeen", value:true});
        $("splash").classList.add("hide");
        setTimeout(()=>$("splash").style.display="none", 600);
      });
      
      $("resetLocalBtn").addEventListener("click", async ()=>{
        if(confirm("Wipe all local data?")){ await DB.wipeAll(); location.reload(); }
      });
      
      $("refreshBtn").addEventListener("click", refreshSources);
      $("useCacheBtn").addEventListener("click", useCache);
      $("exportBtn").addEventListener("click", exportJSON);
      
      $("analyzeOntologyBtn").addEventListener("click", runOntologyAnalysis);
      $("trackTemporalBtn").addEventListener("click", runTemporalTracking);
      $("mapProvenanceBtn").addEventListener("click", runProvenanceMapping);
      $("calculateThresholdsBtn").addEventListener("click", calculateActionThresholds);
      $("runRedTeamBtn").addEventListener("click", runAdversarialTest);
      $("runPerfTestBtn").addEventListener("click", runPerformanceTests);
      
      $("planCluster").addEventListener("change", generateActionPlan);
      
      $("submitPartBtn").addEventListener("click", submitCommunityKnowledge);
      $("clearPartFormBtn").addEventListener("click", ()=>{
        $("partContent").value = "";
        $("partLocation").value = "";
        $("partTime").value = "";
      });
      $("clearAllPartBtn").addEventListener("click", clearAllParticipatory);
      
      $("offlineCacheToggle").addEventListener("change", async ()=>{
        State.settings.offlineCache = $("offlineCacheToggle").checked;
        await persistSettings();
      });
      
      $("autoRefreshToggle").addEventListener("change", async ()=>{
        State.settings.autoRefresh = $("autoRefreshToggle").checked;
        await persistSettings();
      });
      
      $("localAnalyticsToggle").addEventListener("change", async ()=>{
        State.settings.localAnalytics = $("localAnalyticsToggle").checked;
        await persistSettings();
      });
      
      $("resetAnalyticsBtn").addEventListener("click", async ()=>{
        State.analytics = { refreshes:0, modulesRun:0, lastDay:null, streak:0 };
        await persistAnalytics();
        renderHud();
        toast("Analytics reset");
      });
      
      $("swStatusBtn").addEventListener("click", async ()=>{
        const regs = await navigator.serviceWorker.getRegistrations();
        toast(regs.length ? "Service Worker active" : "No SW registered");
      });
      
      $("wipeAllBtn").addEventListener("click", async ()=>{
        if(confirm("Delete all local data?")){ await DB.wipeAll(); location.reload(); }
      });
      
      $("minHudBtn").addEventListener("click", ()=>$("hud").classList.toggle("min"));
      $("hudQuickRefresh").addEventListener("click", refreshSources);
      $("hudSnapshot").addEventListener("click", ()=>toast("Snapshot saved (local)"));
      
      // Auto-refresh if enabled
      if(State.settings.autoRefresh){
        setTimeout(refreshSources, 800);
      } else if(State.lastClusters.length){
        renderFeed();
        updateHeaderPills();
        drawHealthViz();
      }
    })();
  </script>
</body>
</html>
